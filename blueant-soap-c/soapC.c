/* soapC.c
   Generated by gSOAP 2.8.63 for blueant.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.8.63 2018-04-12 14:46:11 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header))))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_ns3__optionalInt:
		return soap_in_ns3__optionalInt(soap, NULL, NULL, "ns3:optionalInt");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_ns3__optionalLong:
		return soap_in_ns3__optionalLong(soap, NULL, NULL, "ns3:optionalLong");
	case SOAP_TYPE_ns3__id:
		return soap_in_ns3__id(soap, NULL, NULL, "ns3:id");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_ns3__optionalDouble:
		return soap_in_ns3__optionalDouble(soap, NULL, NULL, "ns3:optionalDouble");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_ns3__T_USCOREUserState:
		return soap_in_ns3__T_USCOREUserState(soap, NULL, NULL, "ns3:T_UserState");
	case SOAP_TYPE_ns3__T_USCORELicenseType:
		return soap_in_ns3__T_USCORELicenseType(soap, NULL, NULL, "ns3:T_LicenseType");
	case SOAP_TYPE_ns3__optionalBoolean:
		return soap_in_ns3__optionalBoolean(soap, NULL, NULL, "ns3:optionalBoolean");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns2__InvalidLicenseException:
		return soap_in_ns2__InvalidLicenseException(soap, NULL, NULL, "ns2:InvalidLicenseException");
	case SOAP_TYPE_ns2__UserManagementException:
		return soap_in_ns2__UserManagementException(soap, NULL, NULL, "ns2:UserManagementException");
	case SOAP_TYPE_ns3__T_USCOREIdList:
		return soap_in_ns3__T_USCOREIdList(soap, NULL, NULL, "ns3:T_IdList");
	case SOAP_TYPE_ns3__T_USCOREUser:
		return soap_in_ns3__T_USCOREUser(soap, NULL, NULL, "ns3:T_User");
	case SOAP_TYPE_ns3__UserIDInfo:
		return soap_in_ns3__UserIDInfo(soap, NULL, NULL, "ns3:UserIDInfo");
	case SOAP_TYPE_ns3__T_USCOREForeignKeyList:
		return soap_in_ns3__T_USCOREForeignKeyList(soap, NULL, NULL, "ns3:T_ForeignKeyList");
	case SOAP_TYPE_ns3__T_USCOREForeignKey:
		return soap_in_ns3__T_USCOREForeignKey(soap, NULL, NULL, "ns3:T_ForeignKey");
	case SOAP_TYPE_ns2__GeneralWebserviceException:
		return soap_in_ns2__GeneralWebserviceException(soap, NULL, NULL, "ns2:GeneralWebserviceException");
	case SOAP_TYPE_PointerTo_ns3__UserList:
		return soap_in_PointerTo_ns3__UserList(soap, NULL, NULL, "ns3:UserList");
	case SOAP_TYPE_PointerTo_ns3__searchUserRequestParameter:
		return soap_in_PointerTo_ns3__searchUserRequestParameter(soap, NULL, NULL, "ns3:searchUserRequestParameter");
	case SOAP_TYPE_PointerTo_ns3__deleteUserRequestParameter:
		return soap_in_PointerTo_ns3__deleteUserRequestParameter(soap, NULL, NULL, "ns3:deleteUserRequestParameter");
	case SOAP_TYPE_PointerTo_ns3__createUserRequestParameter:
		return soap_in_PointerTo_ns3__createUserRequestParameter(soap, NULL, NULL, "ns3:createUserRequestParameter");
	case SOAP_TYPE_PointerTo_ns3__LogoutRequestParameter:
		return soap_in_PointerTo_ns3__LogoutRequestParameter(soap, NULL, NULL, "ns3:LogoutRequestParameter");
	case SOAP_TYPE_PointerTo_ns3__LoginImpersonateRequestParameter:
		return soap_in_PointerTo_ns3__LoginImpersonateRequestParameter(soap, NULL, NULL, "ns3:LoginImpersonateRequestParameter");
	case SOAP_TYPE_PointerTo_ns3__LoginSAMLRequestParameter:
		return soap_in_PointerTo_ns3__LoginSAMLRequestParameter(soap, NULL, NULL, "ns3:LoginSAMLRequestParameter");
	case SOAP_TYPE_PointerTo_ns3__LoginNoAuthRequestParameter:
		return soap_in_PointerTo_ns3__LoginNoAuthRequestParameter(soap, NULL, NULL, "ns3:LoginNoAuthRequestParameter");
	case SOAP_TYPE_PointerTo_ns3__session:
		return soap_in_PointerTo_ns3__session(soap, NULL, NULL, "ns3:session");
	case SOAP_TYPE_PointerTo_ns3__LoginRequestParameter:
		return soap_in_PointerTo_ns3__LoginRequestParameter(soap, NULL, NULL, "ns3:LoginRequestParameter");
	case SOAP_TYPE_PointerTo_ns2__ServerMaintenanceException:
		return soap_in_PointerTo_ns2__ServerMaintenanceException(soap, NULL, NULL, "ns2:ServerMaintenanceException");
	case SOAP_TYPE_PointerTo_ns2__PermissionDeniedException:
		return soap_in_PointerTo_ns2__PermissionDeniedException(soap, NULL, NULL, "ns2:PermissionDeniedException");
	case SOAP_TYPE_PointerTo_ns2__InvalidUsernamePasswordCombinationException:
		return soap_in_PointerTo_ns2__InvalidUsernamePasswordCombinationException(soap, NULL, NULL, "ns2:InvalidUsernamePasswordCombinationException");
	case SOAP_TYPE_PointerTo_ns2__InvalidUsernameException:
		return soap_in_PointerTo_ns2__InvalidUsernameException(soap, NULL, NULL, "ns2:InvalidUsernameException");
	case SOAP_TYPE_PointerTo_ns2__InvalidSessionException:
		return soap_in_PointerTo_ns2__InvalidSessionException(soap, NULL, NULL, "ns2:InvalidSessionException");
	case SOAP_TYPE_PointerTo_ns2__InvalidParameterException:
		return soap_in_PointerTo_ns2__InvalidParameterException(soap, NULL, NULL, "ns2:InvalidParameterException");
	case SOAP_TYPE_PointerTo_ns2__InvalidNrOfImpersonationsException:
		return soap_in_PointerTo_ns2__InvalidNrOfImpersonationsException(soap, NULL, NULL, "ns2:InvalidNrOfImpersonationsException");
	case SOAP_TYPE_PointerTo_ns2__InvalidNamedLicenseException:
		return soap_in_PointerTo_ns2__InvalidNamedLicenseException(soap, NULL, NULL, "ns2:InvalidNamedLicenseException");
	case SOAP_TYPE_PointerTo_ns2__InvalidDatesException:
		return soap_in_PointerTo_ns2__InvalidDatesException(soap, NULL, NULL, "ns2:InvalidDatesException");
	case SOAP_TYPE_PointerTo_ns2__InvalidConcurrentLicenseException:
		return soap_in_PointerTo_ns2__InvalidConcurrentLicenseException(soap, NULL, NULL, "ns2:InvalidConcurrentLicenseException");
	case SOAP_TYPE_PointerTo_ns2__InvalidClientException:
		return soap_in_PointerTo_ns2__InvalidClientException(soap, NULL, NULL, "ns2:InvalidClientException");
	case SOAP_TYPE_PointerTo_ns2__ImpersonatedUserNotFoundException:
		return soap_in_PointerTo_ns2__ImpersonatedUserNotFoundException(soap, NULL, NULL, "ns2:ImpersonatedUserNotFoundException");
	case SOAP_TYPE_PointerTo_ns2__GeneralWebserviceException:
		return soap_in_PointerTo_ns2__GeneralWebserviceException(soap, NULL, NULL, "ns2:GeneralWebserviceException");
	case SOAP_TYPE_PointerTo_ns2__AssertionException:
		return soap_in_PointerTo_ns2__AssertionException(soap, NULL, NULL, "ns2:AssertionException");
	case SOAP_TYPE_PointerTons3__T_USCOREUser:
		return soap_in_PointerTons3__T_USCOREUser(soap, NULL, NULL, "ns3:T_User");
	case SOAP_TYPE_PointerTons3__UserIDInfo:
		return soap_in_PointerTons3__UserIDInfo(soap, NULL, NULL, "ns3:UserIDInfo");
	case SOAP_TYPE_PointerTons3__T_USCOREUserState:
		return soap_in_PointerTons3__T_USCOREUserState(soap, NULL, NULL, "ns3:T_UserState");
	case SOAP_TYPE_PointerTons3__T_USCORELicenseType:
		return soap_in_PointerTons3__T_USCORELicenseType(soap, NULL, NULL, "ns3:T_LicenseType");
	case SOAP_TYPE_PointerTons3__id:
		return soap_in_PointerTons3__id(soap, NULL, NULL, "ns3:id");
	case SOAP_TYPE_PointerTons3__T_USCOREForeignKeyList:
		return soap_in_PointerTons3__T_USCOREForeignKeyList(soap, NULL, NULL, "ns3:T_ForeignKeyList");
	case SOAP_TYPE_PointerTons3__T_USCOREIdList:
		return soap_in_PointerTons3__T_USCOREIdList(soap, NULL, NULL, "ns3:T_IdList");
	case SOAP_TYPE_PointerTons3__T_USCOREForeignKey:
		return soap_in_PointerTons3__T_USCOREForeignKey(soap, NULL, NULL, "ns3:T_ForeignKey");
	case SOAP_TYPE_xsd__date:
	{	char **s;
		s = soap_in_xsd__date(soap, NULL, NULL, "xsd:date");
		return s ? *s : NULL;
	}
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:optionalInt"))
		{	*type = SOAP_TYPE_ns3__optionalInt;
			return soap_in_ns3__optionalInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:optionalLong"))
		{	*type = SOAP_TYPE_ns3__optionalLong;
			return soap_in_ns3__optionalLong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:id"))
		{	*type = SOAP_TYPE_ns3__id;
			return soap_in_ns3__id(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:optionalDouble"))
		{	*type = SOAP_TYPE_ns3__optionalDouble;
			return soap_in_ns3__optionalDouble(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:T_UserState"))
		{	*type = SOAP_TYPE_ns3__T_USCOREUserState;
			return soap_in_ns3__T_USCOREUserState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:T_LicenseType"))
		{	*type = SOAP_TYPE_ns3__T_USCORELicenseType;
			return soap_in_ns3__T_USCORELicenseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:optionalBoolean"))
		{	*type = SOAP_TYPE_ns3__optionalBoolean;
			return soap_in_ns3__optionalBoolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:InvalidLicenseException"))
		{	*type = SOAP_TYPE_ns2__InvalidLicenseException;
			return soap_in_ns2__InvalidLicenseException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:UserManagementException"))
		{	*type = SOAP_TYPE_ns2__UserManagementException;
			return soap_in_ns2__UserManagementException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:T_IdList"))
		{	*type = SOAP_TYPE_ns3__T_USCOREIdList;
			return soap_in_ns3__T_USCOREIdList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:T_User"))
		{	*type = SOAP_TYPE_ns3__T_USCOREUser;
			return soap_in_ns3__T_USCOREUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UserIDInfo"))
		{	*type = SOAP_TYPE_ns3__UserIDInfo;
			return soap_in_ns3__UserIDInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:T_ForeignKeyList"))
		{	*type = SOAP_TYPE_ns3__T_USCOREForeignKeyList;
			return soap_in_ns3__T_USCOREForeignKeyList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:T_ForeignKey"))
		{	*type = SOAP_TYPE_ns3__T_USCOREForeignKey;
			return soap_in_ns3__T_USCOREForeignKey(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GeneralWebserviceException"))
		{	*type = SOAP_TYPE_ns2__GeneralWebserviceException;
			return soap_in_ns2__GeneralWebserviceException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:date"))
		{	char **s;
			*type = SOAP_TYPE_xsd__date;
			s = soap_in_xsd__date(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns2:InvalidConcurrentLicenseException"))
		{	*type = SOAP_TYPE__ns2__InvalidConcurrentLicenseException;
			return soap_in__ns2__InvalidConcurrentLicenseException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:InvalidNamedLicenseException"))
		{	*type = SOAP_TYPE__ns2__InvalidNamedLicenseException;
			return soap_in__ns2__InvalidNamedLicenseException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:InvalidNrOfImpersonationsException"))
		{	*type = SOAP_TYPE__ns2__InvalidNrOfImpersonationsException;
			return soap_in__ns2__InvalidNrOfImpersonationsException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ImpersonatedUserNotFoundException"))
		{	*type = SOAP_TYPE__ns2__ImpersonatedUserNotFoundException;
			return soap_in__ns2__ImpersonatedUserNotFoundException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ServerMaintenanceException"))
		{	*type = SOAP_TYPE__ns2__ServerMaintenanceException;
			return soap_in__ns2__ServerMaintenanceException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:InvalidDatesException"))
		{	*type = SOAP_TYPE__ns2__InvalidDatesException;
			return soap_in__ns2__InvalidDatesException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:InvalidUsernameException"))
		{	*type = SOAP_TYPE__ns2__InvalidUsernameException;
			return soap_in__ns2__InvalidUsernameException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:InvalidUsernamePasswordCombinationException"))
		{	*type = SOAP_TYPE__ns2__InvalidUsernamePasswordCombinationException;
			return soap_in__ns2__InvalidUsernamePasswordCombinationException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PermissionDeniedException"))
		{	*type = SOAP_TYPE__ns2__PermissionDeniedException;
			return soap_in__ns2__PermissionDeniedException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:InvalidClientException"))
		{	*type = SOAP_TYPE__ns2__InvalidClientException;
			return soap_in__ns2__InvalidClientException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:InvalidSessionException"))
		{	*type = SOAP_TYPE__ns2__InvalidSessionException;
			return soap_in__ns2__InvalidSessionException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GeneralWebserviceException"))
		{	*type = SOAP_TYPE__ns2__GeneralWebserviceException;
			return soap_in__ns2__GeneralWebserviceException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AssertionException"))
		{	*type = SOAP_TYPE__ns2__AssertionException;
			return soap_in__ns2__AssertionException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:InvalidParameterException"))
		{	*type = SOAP_TYPE__ns2__InvalidParameterException;
			return soap_in__ns2__InvalidParameterException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:WeekFinishedException"))
		{	*type = SOAP_TYPE__ns2__WeekFinishedException;
			return soap_in__ns2__WeekFinishedException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UserList"))
		{	*type = SOAP_TYPE__ns3__UserList;
			return soap_in__ns3__UserList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:deleteUserRequestParameter"))
		{	*type = SOAP_TYPE__ns3__deleteUserRequestParameter;
			return soap_in__ns3__deleteUserRequestParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:searchUserRequestParameter"))
		{	*type = SOAP_TYPE__ns3__searchUserRequestParameter;
			return soap_in__ns3__searchUserRequestParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:createUserRequestParameter"))
		{	*type = SOAP_TYPE__ns3__createUserRequestParameter;
			return soap_in__ns3__createUserRequestParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:LogoutRequestParameter"))
		{	*type = SOAP_TYPE__ns3__LogoutRequestParameter;
			return soap_in__ns3__LogoutRequestParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:LoginImpersonateRequestParameter"))
		{	*type = SOAP_TYPE__ns3__LoginImpersonateRequestParameter;
			return soap_in__ns3__LoginImpersonateRequestParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:LoginSAMLRequestParameter"))
		{	*type = SOAP_TYPE__ns3__LoginSAMLRequestParameter;
			return soap_in__ns3__LoginSAMLRequestParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:LoginNoAuthRequestParameter"))
		{	*type = SOAP_TYPE__ns3__LoginNoAuthRequestParameter;
			return soap_in__ns3__LoginNoAuthRequestParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:LoginRequestParameter"))
		{	*type = SOAP_TYPE__ns3__LoginRequestParameter;
			return soap_in__ns3__LoginRequestParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:session"))
		{	*type = SOAP_TYPE__ns3__session;
			return soap_in__ns3__session(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_ns3__optionalInt:
		return soap_out_ns3__optionalInt(soap, tag, id, (const int *)ptr, "ns3:optionalInt");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_ns3__optionalLong:
		return soap_out_ns3__optionalLong(soap, tag, id, (const LONG64 *)ptr, "ns3:optionalLong");
	case SOAP_TYPE_ns3__id:
		return soap_out_ns3__id(soap, tag, id, (const LONG64 *)ptr, "ns3:id");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_ns3__optionalDouble:
		return soap_out_ns3__optionalDouble(soap, tag, id, (const double *)ptr, "ns3:optionalDouble");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_ns3__T_USCOREUserState:
		return soap_out_ns3__T_USCOREUserState(soap, tag, id, (const enum ns3__T_USCOREUserState *)ptr, "ns3:T_UserState");
	case SOAP_TYPE_ns3__T_USCORELicenseType:
		return soap_out_ns3__T_USCORELicenseType(soap, tag, id, (const enum ns3__T_USCORELicenseType *)ptr, "ns3:T_LicenseType");
	case SOAP_TYPE_ns3__optionalBoolean:
		return soap_out_ns3__optionalBoolean(soap, tag, id, (const enum xsd__boolean *)ptr, "ns3:optionalBoolean");
	case SOAP_TYPE_xsd__boolean:
		return soap_out_xsd__boolean(soap, tag, id, (const enum xsd__boolean *)ptr, "xsd:boolean");
	case SOAP_TYPE__ns2__InvalidConcurrentLicenseException:
		return soap_out__ns2__InvalidConcurrentLicenseException(soap, "ns2:InvalidConcurrentLicenseException", id, (const struct _ns2__InvalidConcurrentLicenseException *)ptr, "");
	case SOAP_TYPE__ns2__InvalidNamedLicenseException:
		return soap_out__ns2__InvalidNamedLicenseException(soap, "ns2:InvalidNamedLicenseException", id, (const struct _ns2__InvalidNamedLicenseException *)ptr, "");
	case SOAP_TYPE__ns2__InvalidNrOfImpersonationsException:
		return soap_out__ns2__InvalidNrOfImpersonationsException(soap, "ns2:InvalidNrOfImpersonationsException", id, (const struct _ns2__InvalidNrOfImpersonationsException *)ptr, "");
	case SOAP_TYPE__ns2__ImpersonatedUserNotFoundException:
		return soap_out__ns2__ImpersonatedUserNotFoundException(soap, "ns2:ImpersonatedUserNotFoundException", id, (const struct _ns2__ImpersonatedUserNotFoundException *)ptr, "");
	case SOAP_TYPE__ns2__ServerMaintenanceException:
		return soap_out__ns2__ServerMaintenanceException(soap, "ns2:ServerMaintenanceException", id, (const struct _ns2__ServerMaintenanceException *)ptr, "");
	case SOAP_TYPE__ns2__InvalidDatesException:
		return soap_out__ns2__InvalidDatesException(soap, "ns2:InvalidDatesException", id, (const struct _ns2__InvalidDatesException *)ptr, "");
	case SOAP_TYPE__ns2__InvalidUsernameException:
		return soap_out__ns2__InvalidUsernameException(soap, "ns2:InvalidUsernameException", id, (const struct _ns2__InvalidUsernameException *)ptr, "");
	case SOAP_TYPE__ns2__InvalidUsernamePasswordCombinationException:
		return soap_out__ns2__InvalidUsernamePasswordCombinationException(soap, "ns2:InvalidUsernamePasswordCombinationException", id, (const struct _ns2__InvalidUsernamePasswordCombinationException *)ptr, "");
	case SOAP_TYPE__ns2__PermissionDeniedException:
		return soap_out__ns2__PermissionDeniedException(soap, "ns2:PermissionDeniedException", id, (const struct _ns2__PermissionDeniedException *)ptr, "");
	case SOAP_TYPE__ns2__InvalidClientException:
		return soap_out__ns2__InvalidClientException(soap, "ns2:InvalidClientException", id, (const struct _ns2__InvalidClientException *)ptr, "");
	case SOAP_TYPE__ns2__InvalidSessionException:
		return soap_out__ns2__InvalidSessionException(soap, "ns2:InvalidSessionException", id, (const struct _ns2__InvalidSessionException *)ptr, "");
	case SOAP_TYPE_ns2__InvalidLicenseException:
		return soap_out_ns2__InvalidLicenseException(soap, tag, id, (const struct ns2__InvalidLicenseException *)ptr, "ns2:InvalidLicenseException");
	case SOAP_TYPE__ns2__GeneralWebserviceException:
		return soap_out__ns2__GeneralWebserviceException(soap, "ns2:GeneralWebserviceException", id, (const struct _ns2__GeneralWebserviceException *)ptr, "");
	case SOAP_TYPE__ns2__AssertionException:
		return soap_out__ns2__AssertionException(soap, "ns2:AssertionException", id, (const struct _ns2__AssertionException *)ptr, "");
	case SOAP_TYPE__ns2__InvalidParameterException:
		return soap_out__ns2__InvalidParameterException(soap, "ns2:InvalidParameterException", id, (const struct _ns2__InvalidParameterException *)ptr, "");
	case SOAP_TYPE__ns2__WeekFinishedException:
		return soap_out__ns2__WeekFinishedException(soap, "ns2:WeekFinishedException", id, (const struct _ns2__WeekFinishedException *)ptr, "");
	case SOAP_TYPE_ns2__UserManagementException:
		return soap_out_ns2__UserManagementException(soap, tag, id, (const struct ns2__UserManagementException *)ptr, "ns2:UserManagementException");
	case SOAP_TYPE__ns3__UserList:
		return soap_out__ns3__UserList(soap, "ns3:UserList", id, (const struct _ns3__UserList *)ptr, "");
	case SOAP_TYPE__ns3__deleteUserRequestParameter:
		return soap_out__ns3__deleteUserRequestParameter(soap, "ns3:deleteUserRequestParameter", id, (const struct _ns3__deleteUserRequestParameter *)ptr, "");
	case SOAP_TYPE__ns3__searchUserRequestParameter:
		return soap_out__ns3__searchUserRequestParameter(soap, "ns3:searchUserRequestParameter", id, (const struct _ns3__searchUserRequestParameter *)ptr, "");
	case SOAP_TYPE__ns3__createUserRequestParameter:
		return soap_out__ns3__createUserRequestParameter(soap, "ns3:createUserRequestParameter", id, (const struct _ns3__createUserRequestParameter *)ptr, "");
	case SOAP_TYPE__ns3__LogoutRequestParameter:
		return soap_out__ns3__LogoutRequestParameter(soap, "ns3:LogoutRequestParameter", id, (const struct _ns3__LogoutRequestParameter *)ptr, "");
	case SOAP_TYPE__ns3__LoginImpersonateRequestParameter:
		return soap_out__ns3__LoginImpersonateRequestParameter(soap, "ns3:LoginImpersonateRequestParameter", id, (const struct _ns3__LoginImpersonateRequestParameter *)ptr, "");
	case SOAP_TYPE__ns3__LoginSAMLRequestParameter:
		return soap_out__ns3__LoginSAMLRequestParameter(soap, "ns3:LoginSAMLRequestParameter", id, (const struct _ns3__LoginSAMLRequestParameter *)ptr, "");
	case SOAP_TYPE__ns3__LoginNoAuthRequestParameter:
		return soap_out__ns3__LoginNoAuthRequestParameter(soap, "ns3:LoginNoAuthRequestParameter", id, (const struct _ns3__LoginNoAuthRequestParameter *)ptr, "");
	case SOAP_TYPE__ns3__LoginRequestParameter:
		return soap_out__ns3__LoginRequestParameter(soap, "ns3:LoginRequestParameter", id, (const struct _ns3__LoginRequestParameter *)ptr, "");
	case SOAP_TYPE__ns3__session:
		return soap_out__ns3__session(soap, "ns3:session", id, (const struct _ns3__session *)ptr, "");
	case SOAP_TYPE_ns3__T_USCOREIdList:
		return soap_out_ns3__T_USCOREIdList(soap, tag, id, (const struct ns3__T_USCOREIdList *)ptr, "ns3:T_IdList");
	case SOAP_TYPE_ns3__T_USCOREUser:
		return soap_out_ns3__T_USCOREUser(soap, tag, id, (const struct ns3__T_USCOREUser *)ptr, "ns3:T_User");
	case SOAP_TYPE_ns3__UserIDInfo:
		return soap_out_ns3__UserIDInfo(soap, tag, id, (const struct ns3__UserIDInfo *)ptr, "ns3:UserIDInfo");
	case SOAP_TYPE_ns3__T_USCOREForeignKeyList:
		return soap_out_ns3__T_USCOREForeignKeyList(soap, tag, id, (const struct ns3__T_USCOREForeignKeyList *)ptr, "ns3:T_ForeignKeyList");
	case SOAP_TYPE_ns3__T_USCOREForeignKey:
		return soap_out_ns3__T_USCOREForeignKey(soap, tag, id, (const struct ns3__T_USCOREForeignKey *)ptr, "ns3:T_ForeignKey");
	case SOAP_TYPE_ns2__GeneralWebserviceException:
		return soap_out_ns2__GeneralWebserviceException(soap, tag, id, (const struct ns2__GeneralWebserviceException *)ptr, "ns2:GeneralWebserviceException");
	case SOAP_TYPE_PointerTo_ns3__UserList:
		return soap_out_PointerTo_ns3__UserList(soap, tag, id, (struct _ns3__UserList *const*)ptr, "ns3:UserList");
	case SOAP_TYPE_PointerTo_ns3__searchUserRequestParameter:
		return soap_out_PointerTo_ns3__searchUserRequestParameter(soap, tag, id, (struct _ns3__searchUserRequestParameter *const*)ptr, "ns3:searchUserRequestParameter");
	case SOAP_TYPE_PointerTo_ns3__deleteUserRequestParameter:
		return soap_out_PointerTo_ns3__deleteUserRequestParameter(soap, tag, id, (struct _ns3__deleteUserRequestParameter *const*)ptr, "ns3:deleteUserRequestParameter");
	case SOAP_TYPE_PointerTo_ns3__createUserRequestParameter:
		return soap_out_PointerTo_ns3__createUserRequestParameter(soap, tag, id, (struct _ns3__createUserRequestParameter *const*)ptr, "ns3:createUserRequestParameter");
	case SOAP_TYPE_PointerTo_ns3__LogoutRequestParameter:
		return soap_out_PointerTo_ns3__LogoutRequestParameter(soap, tag, id, (struct _ns3__LogoutRequestParameter *const*)ptr, "ns3:LogoutRequestParameter");
	case SOAP_TYPE_PointerTo_ns3__LoginImpersonateRequestParameter:
		return soap_out_PointerTo_ns3__LoginImpersonateRequestParameter(soap, tag, id, (struct _ns3__LoginImpersonateRequestParameter *const*)ptr, "ns3:LoginImpersonateRequestParameter");
	case SOAP_TYPE_PointerTo_ns3__LoginSAMLRequestParameter:
		return soap_out_PointerTo_ns3__LoginSAMLRequestParameter(soap, tag, id, (struct _ns3__LoginSAMLRequestParameter *const*)ptr, "ns3:LoginSAMLRequestParameter");
	case SOAP_TYPE_PointerTo_ns3__LoginNoAuthRequestParameter:
		return soap_out_PointerTo_ns3__LoginNoAuthRequestParameter(soap, tag, id, (struct _ns3__LoginNoAuthRequestParameter *const*)ptr, "ns3:LoginNoAuthRequestParameter");
	case SOAP_TYPE_PointerTo_ns3__session:
		return soap_out_PointerTo_ns3__session(soap, tag, id, (struct _ns3__session *const*)ptr, "ns3:session");
	case SOAP_TYPE_PointerTo_ns3__LoginRequestParameter:
		return soap_out_PointerTo_ns3__LoginRequestParameter(soap, tag, id, (struct _ns3__LoginRequestParameter *const*)ptr, "ns3:LoginRequestParameter");
	case SOAP_TYPE_PointerTo_ns2__ServerMaintenanceException:
		return soap_out_PointerTo_ns2__ServerMaintenanceException(soap, tag, id, (struct _ns2__ServerMaintenanceException *const*)ptr, "ns2:ServerMaintenanceException");
	case SOAP_TYPE_PointerTo_ns2__PermissionDeniedException:
		return soap_out_PointerTo_ns2__PermissionDeniedException(soap, tag, id, (struct _ns2__PermissionDeniedException *const*)ptr, "ns2:PermissionDeniedException");
	case SOAP_TYPE_PointerTo_ns2__InvalidUsernamePasswordCombinationException:
		return soap_out_PointerTo_ns2__InvalidUsernamePasswordCombinationException(soap, tag, id, (struct _ns2__InvalidUsernamePasswordCombinationException *const*)ptr, "ns2:InvalidUsernamePasswordCombinationException");
	case SOAP_TYPE_PointerTo_ns2__InvalidUsernameException:
		return soap_out_PointerTo_ns2__InvalidUsernameException(soap, tag, id, (struct _ns2__InvalidUsernameException *const*)ptr, "ns2:InvalidUsernameException");
	case SOAP_TYPE_PointerTo_ns2__InvalidSessionException:
		return soap_out_PointerTo_ns2__InvalidSessionException(soap, tag, id, (struct _ns2__InvalidSessionException *const*)ptr, "ns2:InvalidSessionException");
	case SOAP_TYPE_PointerTo_ns2__InvalidParameterException:
		return soap_out_PointerTo_ns2__InvalidParameterException(soap, tag, id, (struct _ns2__InvalidParameterException *const*)ptr, "ns2:InvalidParameterException");
	case SOAP_TYPE_PointerTo_ns2__InvalidNrOfImpersonationsException:
		return soap_out_PointerTo_ns2__InvalidNrOfImpersonationsException(soap, tag, id, (struct _ns2__InvalidNrOfImpersonationsException *const*)ptr, "ns2:InvalidNrOfImpersonationsException");
	case SOAP_TYPE_PointerTo_ns2__InvalidNamedLicenseException:
		return soap_out_PointerTo_ns2__InvalidNamedLicenseException(soap, tag, id, (struct _ns2__InvalidNamedLicenseException *const*)ptr, "ns2:InvalidNamedLicenseException");
	case SOAP_TYPE_PointerTo_ns2__InvalidDatesException:
		return soap_out_PointerTo_ns2__InvalidDatesException(soap, tag, id, (struct _ns2__InvalidDatesException *const*)ptr, "ns2:InvalidDatesException");
	case SOAP_TYPE_PointerTo_ns2__InvalidConcurrentLicenseException:
		return soap_out_PointerTo_ns2__InvalidConcurrentLicenseException(soap, tag, id, (struct _ns2__InvalidConcurrentLicenseException *const*)ptr, "ns2:InvalidConcurrentLicenseException");
	case SOAP_TYPE_PointerTo_ns2__InvalidClientException:
		return soap_out_PointerTo_ns2__InvalidClientException(soap, tag, id, (struct _ns2__InvalidClientException *const*)ptr, "ns2:InvalidClientException");
	case SOAP_TYPE_PointerTo_ns2__ImpersonatedUserNotFoundException:
		return soap_out_PointerTo_ns2__ImpersonatedUserNotFoundException(soap, tag, id, (struct _ns2__ImpersonatedUserNotFoundException *const*)ptr, "ns2:ImpersonatedUserNotFoundException");
	case SOAP_TYPE_PointerTo_ns2__GeneralWebserviceException:
		return soap_out_PointerTo_ns2__GeneralWebserviceException(soap, tag, id, (struct _ns2__GeneralWebserviceException *const*)ptr, "ns2:GeneralWebserviceException");
	case SOAP_TYPE_PointerTo_ns2__AssertionException:
		return soap_out_PointerTo_ns2__AssertionException(soap, tag, id, (struct _ns2__AssertionException *const*)ptr, "ns2:AssertionException");
	case SOAP_TYPE_PointerTons3__T_USCOREUser:
		return soap_out_PointerTons3__T_USCOREUser(soap, tag, id, (struct ns3__T_USCOREUser *const*)ptr, "ns3:T_User");
	case SOAP_TYPE_PointerTons3__UserIDInfo:
		return soap_out_PointerTons3__UserIDInfo(soap, tag, id, (struct ns3__UserIDInfo *const*)ptr, "ns3:UserIDInfo");
	case SOAP_TYPE_PointerTons3__T_USCOREUserState:
		return soap_out_PointerTons3__T_USCOREUserState(soap, tag, id, (enum ns3__T_USCOREUserState *const*)ptr, "ns3:T_UserState");
	case SOAP_TYPE_PointerTons3__T_USCORELicenseType:
		return soap_out_PointerTons3__T_USCORELicenseType(soap, tag, id, (enum ns3__T_USCORELicenseType *const*)ptr, "ns3:T_LicenseType");
	case SOAP_TYPE_PointerTons3__id:
		return soap_out_PointerTons3__id(soap, tag, id, (LONG64 *const*)ptr, "ns3:id");
	case SOAP_TYPE_PointerTons3__T_USCOREForeignKeyList:
		return soap_out_PointerTons3__T_USCOREForeignKeyList(soap, tag, id, (struct ns3__T_USCOREForeignKeyList *const*)ptr, "ns3:T_ForeignKeyList");
	case SOAP_TYPE_PointerTons3__T_USCOREIdList:
		return soap_out_PointerTons3__T_USCOREIdList(soap, tag, id, (struct ns3__T_USCOREIdList *const*)ptr, "ns3:T_IdList");
	case SOAP_TYPE_PointerTons3__T_USCOREForeignKey:
		return soap_out_PointerTons3__T_USCOREForeignKey(soap, tag, id, (struct ns3__T_USCOREForeignKey *const*)ptr, "ns3:T_ForeignKey");
	case SOAP_TYPE_xsd__date:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:date");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in soapC.c\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag); /* unknown type to serialize */
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE___ns1__searchUser:
		soap_serialize___ns1__searchUser(soap, (const struct __ns1__searchUser *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteUser:
		soap_serialize___ns1__deleteUser(soap, (const struct __ns1__deleteUser *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteUserResponse:
		soap_serialize___ns1__deleteUserResponse(soap, (const struct __ns1__deleteUserResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__createUser:
		soap_serialize___ns1__createUser(soap, (const struct __ns1__createUser *)ptr);
		break;
	case SOAP_TYPE___ns1__Logout:
		soap_serialize___ns1__Logout(soap, (const struct __ns1__Logout *)ptr);
		break;
	case SOAP_TYPE___ns1__LogoutResponse:
		soap_serialize___ns1__LogoutResponse(soap, (const struct __ns1__LogoutResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__LoginImpersonate:
		soap_serialize___ns1__LoginImpersonate(soap, (const struct __ns1__LoginImpersonate *)ptr);
		break;
	case SOAP_TYPE___ns1__LoginSAML:
		soap_serialize___ns1__LoginSAML(soap, (const struct __ns1__LoginSAML *)ptr);
		break;
	case SOAP_TYPE___ns1__LoginNoAuth:
		soap_serialize___ns1__LoginNoAuth(soap, (const struct __ns1__LoginNoAuth *)ptr);
		break;
	case SOAP_TYPE___ns1__Login:
		soap_serialize___ns1__Login(soap, (const struct __ns1__Login *)ptr);
		break;
	case SOAP_TYPE__ns2__InvalidConcurrentLicenseException:
		soap_serialize__ns2__InvalidConcurrentLicenseException(soap, (const struct _ns2__InvalidConcurrentLicenseException *)ptr);
		break;
	case SOAP_TYPE__ns2__InvalidNamedLicenseException:
		soap_serialize__ns2__InvalidNamedLicenseException(soap, (const struct _ns2__InvalidNamedLicenseException *)ptr);
		break;
	case SOAP_TYPE__ns2__InvalidNrOfImpersonationsException:
		soap_serialize__ns2__InvalidNrOfImpersonationsException(soap, (const struct _ns2__InvalidNrOfImpersonationsException *)ptr);
		break;
	case SOAP_TYPE__ns2__ImpersonatedUserNotFoundException:
		soap_serialize__ns2__ImpersonatedUserNotFoundException(soap, (const struct _ns2__ImpersonatedUserNotFoundException *)ptr);
		break;
	case SOAP_TYPE__ns2__ServerMaintenanceException:
		soap_serialize__ns2__ServerMaintenanceException(soap, (const struct _ns2__ServerMaintenanceException *)ptr);
		break;
	case SOAP_TYPE__ns2__InvalidDatesException:
		soap_serialize__ns2__InvalidDatesException(soap, (const struct _ns2__InvalidDatesException *)ptr);
		break;
	case SOAP_TYPE__ns2__InvalidUsernameException:
		soap_serialize__ns2__InvalidUsernameException(soap, (const struct _ns2__InvalidUsernameException *)ptr);
		break;
	case SOAP_TYPE__ns2__InvalidUsernamePasswordCombinationException:
		soap_serialize__ns2__InvalidUsernamePasswordCombinationException(soap, (const struct _ns2__InvalidUsernamePasswordCombinationException *)ptr);
		break;
	case SOAP_TYPE__ns2__PermissionDeniedException:
		soap_serialize__ns2__PermissionDeniedException(soap, (const struct _ns2__PermissionDeniedException *)ptr);
		break;
	case SOAP_TYPE__ns2__InvalidClientException:
		soap_serialize__ns2__InvalidClientException(soap, (const struct _ns2__InvalidClientException *)ptr);
		break;
	case SOAP_TYPE__ns2__InvalidSessionException:
		soap_serialize__ns2__InvalidSessionException(soap, (const struct _ns2__InvalidSessionException *)ptr);
		break;
	case SOAP_TYPE_ns2__InvalidLicenseException:
		soap_serialize_ns2__InvalidLicenseException(soap, (const struct ns2__InvalidLicenseException *)ptr);
		break;
	case SOAP_TYPE__ns2__GeneralWebserviceException:
		soap_serialize__ns2__GeneralWebserviceException(soap, (const struct _ns2__GeneralWebserviceException *)ptr);
		break;
	case SOAP_TYPE__ns2__AssertionException:
		soap_serialize__ns2__AssertionException(soap, (const struct _ns2__AssertionException *)ptr);
		break;
	case SOAP_TYPE__ns2__InvalidParameterException:
		soap_serialize__ns2__InvalidParameterException(soap, (const struct _ns2__InvalidParameterException *)ptr);
		break;
	case SOAP_TYPE__ns2__WeekFinishedException:
		soap_serialize__ns2__WeekFinishedException(soap, (const struct _ns2__WeekFinishedException *)ptr);
		break;
	case SOAP_TYPE_ns2__UserManagementException:
		soap_serialize_ns2__UserManagementException(soap, (const struct ns2__UserManagementException *)ptr);
		break;
	case SOAP_TYPE__ns3__UserList:
		soap_serialize__ns3__UserList(soap, (const struct _ns3__UserList *)ptr);
		break;
	case SOAP_TYPE__ns3__deleteUserRequestParameter:
		soap_serialize__ns3__deleteUserRequestParameter(soap, (const struct _ns3__deleteUserRequestParameter *)ptr);
		break;
	case SOAP_TYPE__ns3__searchUserRequestParameter:
		soap_serialize__ns3__searchUserRequestParameter(soap, (const struct _ns3__searchUserRequestParameter *)ptr);
		break;
	case SOAP_TYPE__ns3__createUserRequestParameter:
		soap_serialize__ns3__createUserRequestParameter(soap, (const struct _ns3__createUserRequestParameter *)ptr);
		break;
	case SOAP_TYPE__ns3__LogoutRequestParameter:
		soap_serialize__ns3__LogoutRequestParameter(soap, (const struct _ns3__LogoutRequestParameter *)ptr);
		break;
	case SOAP_TYPE__ns3__LoginImpersonateRequestParameter:
		soap_serialize__ns3__LoginImpersonateRequestParameter(soap, (const struct _ns3__LoginImpersonateRequestParameter *)ptr);
		break;
	case SOAP_TYPE__ns3__LoginSAMLRequestParameter:
		soap_serialize__ns3__LoginSAMLRequestParameter(soap, (const struct _ns3__LoginSAMLRequestParameter *)ptr);
		break;
	case SOAP_TYPE__ns3__LoginNoAuthRequestParameter:
		soap_serialize__ns3__LoginNoAuthRequestParameter(soap, (const struct _ns3__LoginNoAuthRequestParameter *)ptr);
		break;
	case SOAP_TYPE__ns3__LoginRequestParameter:
		soap_serialize__ns3__LoginRequestParameter(soap, (const struct _ns3__LoginRequestParameter *)ptr);
		break;
	case SOAP_TYPE__ns3__session:
		soap_serialize__ns3__session(soap, (const struct _ns3__session *)ptr);
		break;
	case SOAP_TYPE_ns3__T_USCOREIdList:
		soap_serialize_ns3__T_USCOREIdList(soap, (const struct ns3__T_USCOREIdList *)ptr);
		break;
	case SOAP_TYPE_ns3__T_USCOREUser:
		soap_serialize_ns3__T_USCOREUser(soap, (const struct ns3__T_USCOREUser *)ptr);
		break;
	case SOAP_TYPE_ns3__UserIDInfo:
		soap_serialize_ns3__UserIDInfo(soap, (const struct ns3__UserIDInfo *)ptr);
		break;
	case SOAP_TYPE_ns3__T_USCOREForeignKeyList:
		soap_serialize_ns3__T_USCOREForeignKeyList(soap, (const struct ns3__T_USCOREForeignKeyList *)ptr);
		break;
	case SOAP_TYPE_ns3__T_USCOREForeignKey:
		soap_serialize_ns3__T_USCOREForeignKey(soap, (const struct ns3__T_USCOREForeignKey *)ptr);
		break;
	case SOAP_TYPE_ns2__GeneralWebserviceException:
		soap_serialize_ns2__GeneralWebserviceException(soap, (const struct ns2__GeneralWebserviceException *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__UserList:
		soap_serialize_PointerTo_ns3__UserList(soap, (struct _ns3__UserList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__searchUserRequestParameter:
		soap_serialize_PointerTo_ns3__searchUserRequestParameter(soap, (struct _ns3__searchUserRequestParameter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns1__deleteUserResponse:
		soap_serialize_PointerTo__ns1__deleteUserResponse(soap, (struct __ns1__deleteUserResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__deleteUserRequestParameter:
		soap_serialize_PointerTo_ns3__deleteUserRequestParameter(soap, (struct _ns3__deleteUserRequestParameter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__createUserRequestParameter:
		soap_serialize_PointerTo_ns3__createUserRequestParameter(soap, (struct _ns3__createUserRequestParameter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns1__LogoutResponse:
		soap_serialize_PointerTo__ns1__LogoutResponse(soap, (struct __ns1__LogoutResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__LogoutRequestParameter:
		soap_serialize_PointerTo_ns3__LogoutRequestParameter(soap, (struct _ns3__LogoutRequestParameter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__LoginImpersonateRequestParameter:
		soap_serialize_PointerTo_ns3__LoginImpersonateRequestParameter(soap, (struct _ns3__LoginImpersonateRequestParameter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__LoginSAMLRequestParameter:
		soap_serialize_PointerTo_ns3__LoginSAMLRequestParameter(soap, (struct _ns3__LoginSAMLRequestParameter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__LoginNoAuthRequestParameter:
		soap_serialize_PointerTo_ns3__LoginNoAuthRequestParameter(soap, (struct _ns3__LoginNoAuthRequestParameter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__session:
		soap_serialize_PointerTo_ns3__session(soap, (struct _ns3__session *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__LoginRequestParameter:
		soap_serialize_PointerTo_ns3__LoginRequestParameter(soap, (struct _ns3__LoginRequestParameter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__ServerMaintenanceException:
		soap_serialize_PointerTo_ns2__ServerMaintenanceException(soap, (struct _ns2__ServerMaintenanceException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__PermissionDeniedException:
		soap_serialize_PointerTo_ns2__PermissionDeniedException(soap, (struct _ns2__PermissionDeniedException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__InvalidUsernamePasswordCombinationException:
		soap_serialize_PointerTo_ns2__InvalidUsernamePasswordCombinationException(soap, (struct _ns2__InvalidUsernamePasswordCombinationException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__InvalidUsernameException:
		soap_serialize_PointerTo_ns2__InvalidUsernameException(soap, (struct _ns2__InvalidUsernameException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__InvalidSessionException:
		soap_serialize_PointerTo_ns2__InvalidSessionException(soap, (struct _ns2__InvalidSessionException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__InvalidParameterException:
		soap_serialize_PointerTo_ns2__InvalidParameterException(soap, (struct _ns2__InvalidParameterException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__InvalidNrOfImpersonationsException:
		soap_serialize_PointerTo_ns2__InvalidNrOfImpersonationsException(soap, (struct _ns2__InvalidNrOfImpersonationsException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__InvalidNamedLicenseException:
		soap_serialize_PointerTo_ns2__InvalidNamedLicenseException(soap, (struct _ns2__InvalidNamedLicenseException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__InvalidDatesException:
		soap_serialize_PointerTo_ns2__InvalidDatesException(soap, (struct _ns2__InvalidDatesException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__InvalidConcurrentLicenseException:
		soap_serialize_PointerTo_ns2__InvalidConcurrentLicenseException(soap, (struct _ns2__InvalidConcurrentLicenseException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__InvalidClientException:
		soap_serialize_PointerTo_ns2__InvalidClientException(soap, (struct _ns2__InvalidClientException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__ImpersonatedUserNotFoundException:
		soap_serialize_PointerTo_ns2__ImpersonatedUserNotFoundException(soap, (struct _ns2__ImpersonatedUserNotFoundException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__GeneralWebserviceException:
		soap_serialize_PointerTo_ns2__GeneralWebserviceException(soap, (struct _ns2__GeneralWebserviceException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__AssertionException:
		soap_serialize_PointerTo_ns2__AssertionException(soap, (struct _ns2__AssertionException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__T_USCOREUser:
		soap_serialize_PointerTons3__T_USCOREUser(soap, (struct ns3__T_USCOREUser *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__UserIDInfo:
		soap_serialize_PointerTons3__UserIDInfo(soap, (struct ns3__UserIDInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__T_USCOREUserState:
		soap_serialize_PointerTons3__T_USCOREUserState(soap, (enum ns3__T_USCOREUserState *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__T_USCORELicenseType:
		soap_serialize_PointerTons3__T_USCORELicenseType(soap, (enum ns3__T_USCORELicenseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__id:
		soap_serialize_PointerTons3__id(soap, (LONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__T_USCOREForeignKeyList:
		soap_serialize_PointerTons3__T_USCOREForeignKeyList(soap, (struct ns3__T_USCOREForeignKeyList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__T_USCOREIdList:
		soap_serialize_PointerTons3__T_USCOREIdList(soap, (struct ns3__T_USCOREIdList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__T_USCOREForeignKey:
		soap_serialize_PointerTons3__T_USCOREForeignKey(soap, (struct ns3__T_USCOREForeignKey *const*)ptr);
		break;
	case SOAP_TYPE_xsd__date:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *p;
	char *a = (char*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(char));
	for (p = a; p && n--; p++)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__optionalInt(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_ns3__optionalInt);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_ns3__optionalInt(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_ns3__optionalInt);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__optionalInt(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_ns3__optionalInt(soap, tag ? tag : "ns3:optionalInt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_ns3__optionalInt(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__optionalInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *p;
	int *a = (int*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(int));
	for (p = a; p && n--; p++)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__optionalLong(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_ns3__optionalLong);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_ns3__optionalLong(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	a = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_ns3__optionalLong);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__optionalLong(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	if (soap_out_ns3__optionalLong(soap, tag ? tag : "ns3:optionalLong", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_ns3__optionalLong(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__optionalLong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__id(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_ns3__id);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_ns3__id(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	a = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_ns3__id);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__id(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	if (soap_out_ns3__id(soap, tag ? tag : "ns3:id", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_ns3__id(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__id(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	a = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return a;
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_new_LONG64(struct soap *soap, int n)
{
	LONG64 *p;
	LONG64 *a = (LONG64*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(LONG64));
	for (p = a; p && n--; p++)
		soap_default_LONG64(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	if (soap_out_LONG64(soap, tag ? tag : "long", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__optionalDouble(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_ns3__optionalDouble);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_ns3__optionalDouble(struct soap *soap, const char *tag, double *a, const char *type)
{
	a = soap_indouble(soap, tag, a, type, SOAP_TYPE_ns3__optionalDouble);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__optionalDouble(struct soap *soap, const double *a, const char *tag, const char *type)
{
	if (soap_out_ns3__optionalDouble(soap, tag ? tag : "ns3:optionalDouble", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_ns3__optionalDouble(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__optionalDouble(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	a = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return a;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_new_double(struct soap *soap, int n)
{
	double *p;
	double *a = (double*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(double));
	for (p = a; p && n--; p++)
		soap_default_double(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	if (soap_out_double(soap, tag ? tag : "double", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns3__T_USCOREUserState[] =
{	{ (LONG64)ns3__T_USCOREUserState__active, "active" },
	{ (LONG64)ns3__T_USCOREUserState__locked, "locked" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns3__T_USCOREUserState2s(struct soap *soap, enum ns3__T_USCOREUserState n)
{	const char *s = soap_code_str(soap_codes_ns3__T_USCOREUserState, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__T_USCOREUserState(struct soap *soap, const char *tag, int id, const enum ns3__T_USCOREUserState *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__T_USCOREUserState), type) || soap_send(soap, soap_ns3__T_USCOREUserState2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns3__T_USCOREUserState(struct soap *soap, const char *s, enum ns3__T_USCOREUserState *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns3__T_USCOREUserState, s);
	if (map)
		*a = (enum ns3__T_USCOREUserState)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum ns3__T_USCOREUserState)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns3__T_USCOREUserState * SOAP_FMAC4 soap_in_ns3__T_USCOREUserState(struct soap *soap, const char *tag, enum ns3__T_USCOREUserState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns3__T_USCOREUserState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__T_USCOREUserState, sizeof(enum ns3__T_USCOREUserState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns3__T_USCOREUserState(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns3__T_USCOREUserState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__T_USCOREUserState, SOAP_TYPE_ns3__T_USCOREUserState, sizeof(enum ns3__T_USCOREUserState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns3__T_USCOREUserState * SOAP_FMAC4 soap_new_ns3__T_USCOREUserState(struct soap *soap, int n)
{
	enum ns3__T_USCOREUserState *p;
	enum ns3__T_USCOREUserState *a = (enum ns3__T_USCOREUserState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum ns3__T_USCOREUserState));
	for (p = a; p && n--; p++)
		soap_default_ns3__T_USCOREUserState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__T_USCOREUserState(struct soap *soap, const enum ns3__T_USCOREUserState *a, const char *tag, const char *type)
{
	if (soap_out_ns3__T_USCOREUserState(soap, tag ? tag : "ns3:T_UserState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns3__T_USCOREUserState * SOAP_FMAC4 soap_get_ns3__T_USCOREUserState(struct soap *soap, enum ns3__T_USCOREUserState *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__T_USCOREUserState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns3__T_USCORELicenseType[] =
{	{ (LONG64)ns3__T_USCORELicenseType__named, "named" },
	{ (LONG64)ns3__T_USCORELicenseType__concurrent, "concurrent" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns3__T_USCORELicenseType2s(struct soap *soap, enum ns3__T_USCORELicenseType n)
{	const char *s = soap_code_str(soap_codes_ns3__T_USCORELicenseType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__T_USCORELicenseType(struct soap *soap, const char *tag, int id, const enum ns3__T_USCORELicenseType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__T_USCORELicenseType), type) || soap_send(soap, soap_ns3__T_USCORELicenseType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns3__T_USCORELicenseType(struct soap *soap, const char *s, enum ns3__T_USCORELicenseType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns3__T_USCORELicenseType, s);
	if (map)
		*a = (enum ns3__T_USCORELicenseType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum ns3__T_USCORELicenseType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns3__T_USCORELicenseType * SOAP_FMAC4 soap_in_ns3__T_USCORELicenseType(struct soap *soap, const char *tag, enum ns3__T_USCORELicenseType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns3__T_USCORELicenseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__T_USCORELicenseType, sizeof(enum ns3__T_USCORELicenseType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns3__T_USCORELicenseType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns3__T_USCORELicenseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__T_USCORELicenseType, SOAP_TYPE_ns3__T_USCORELicenseType, sizeof(enum ns3__T_USCORELicenseType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns3__T_USCORELicenseType * SOAP_FMAC4 soap_new_ns3__T_USCORELicenseType(struct soap *soap, int n)
{
	enum ns3__T_USCORELicenseType *p;
	enum ns3__T_USCORELicenseType *a = (enum ns3__T_USCORELicenseType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum ns3__T_USCORELicenseType));
	for (p = a; p && n--; p++)
		soap_default_ns3__T_USCORELicenseType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__T_USCORELicenseType(struct soap *soap, const enum ns3__T_USCORELicenseType *a, const char *tag, const char *type)
{
	if (soap_out_ns3__T_USCORELicenseType(soap, tag ? tag : "ns3:T_LicenseType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns3__T_USCORELicenseType * SOAP_FMAC4 soap_get_ns3__T_USCORELicenseType(struct soap *soap, enum ns3__T_USCORELicenseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__T_USCORELicenseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__optionalBoolean(struct soap *soap, const char *tag, int id, const enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__optionalBoolean), type) || soap_send(soap, soap_ns3__optionalBoolean2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_in_ns3__optionalBoolean(struct soap *soap, const char *tag, enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum xsd__boolean *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__optionalBoolean, sizeof(enum xsd__boolean), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns3__optionalBoolean(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum xsd__boolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__optionalBoolean, SOAP_TYPE_ns3__optionalBoolean, sizeof(enum xsd__boolean), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__optionalBoolean(struct soap *soap, const enum xsd__boolean *a, const char *tag, const char *type)
{
	if (soap_out_ns3__optionalBoolean(soap, tag ? tag : "ns3:optionalBoolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_get_ns3__optionalBoolean(struct soap *soap, enum xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__optionalBoolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_xsd__boolean[] =
{	{ (LONG64)xsd__boolean__false_, "false" },
	{ (LONG64)xsd__boolean__true_, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__boolean2s(struct soap *soap, enum xsd__boolean n)
{
	(void)soap; /* appease -Wall -Werror */
	return soap_code_str(soap_codes_xsd__boolean, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean), type) || soap_send(soap, soap_xsd__boolean2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__boolean(struct soap *soap, const char *s, enum xsd__boolean *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_xsd__boolean, s);
	if (map)
		*a = (enum xsd__boolean)(map->code != 0);
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum xsd__boolean)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum xsd__boolean *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2xsd__boolean(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum xsd__boolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__boolean, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_new_xsd__boolean(struct soap *soap, int n)
{
	enum xsd__boolean *p;
	enum xsd__boolean *a = (enum xsd__boolean*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum xsd__boolean));
	for (p = a; p && n--; p++)
		soap_default_xsd__boolean(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean(struct soap *soap, const enum xsd__boolean *a, const char *tag, const char *type)
{
	if (soap_out_xsd__boolean(soap, tag ? tag : "xsd:boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, enum xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{
	struct SOAP_ENV__Fault *p;
	struct SOAP_ENV__Fault *a = (struct SOAP_ENV__Fault*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Fault));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Fault(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{
	struct SOAP_ENV__Reason *p;
	struct SOAP_ENV__Reason *a = (struct SOAP_ENV__Reason*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Reason));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Reason(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{
	struct SOAP_ENV__Code *p;
	struct SOAP_ENV__Code *a = (struct SOAP_ENV__Code*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Code));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Code(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{
	struct SOAP_ENV__Header *p;
	struct SOAP_ENV__Header *a = (struct SOAP_ENV__Header*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Header));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Header(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__searchUser(struct soap *soap, struct __ns1__searchUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__searchUserRequestParameter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__searchUser(struct soap *soap, const struct __ns1__searchUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__searchUserRequestParameter(soap, &a->ns3__searchUserRequestParameter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__searchUser(struct soap *soap, const char *tag, int id, const struct __ns1__searchUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__searchUserRequestParameter(soap, "ns3:searchUserRequestParameter", -1, &a->ns3__searchUserRequestParameter, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchUser * SOAP_FMAC4 soap_in___ns1__searchUser(struct soap *soap, const char *tag, struct __ns1__searchUser *a, const char *type)
{
	size_t soap_flag_ns3__searchUserRequestParameter = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__searchUser *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__searchUser, sizeof(struct __ns1__searchUser), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__searchUser(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__searchUserRequestParameter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__searchUserRequestParameter(soap, "ns3:searchUserRequestParameter", &a->ns3__searchUserRequestParameter, ""))
				{	soap_flag_ns3__searchUserRequestParameter--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__searchUser * SOAP_FMAC4 soap_new___ns1__searchUser(struct soap *soap, int n)
{
	struct __ns1__searchUser *p;
	struct __ns1__searchUser *a = (struct __ns1__searchUser*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__searchUser));
	for (p = a; p && n--; p++)
		soap_default___ns1__searchUser(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__searchUser(struct soap *soap, const struct __ns1__searchUser *a, const char *tag, const char *type)
{
	if (soap_out___ns1__searchUser(soap, tag ? tag : "-ns1:searchUser", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchUser * SOAP_FMAC4 soap_get___ns1__searchUser(struct soap *soap, struct __ns1__searchUser *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__searchUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteUser(struct soap *soap, struct __ns1__deleteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__deleteUserRequestParameter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteUser(struct soap *soap, const struct __ns1__deleteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__deleteUserRequestParameter(soap, &a->ns3__deleteUserRequestParameter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteUser(struct soap *soap, const char *tag, int id, const struct __ns1__deleteUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__deleteUserRequestParameter(soap, "ns3:deleteUserRequestParameter", -1, &a->ns3__deleteUserRequestParameter, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteUser * SOAP_FMAC4 soap_in___ns1__deleteUser(struct soap *soap, const char *tag, struct __ns1__deleteUser *a, const char *type)
{
	size_t soap_flag_ns3__deleteUserRequestParameter = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__deleteUser *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteUser, sizeof(struct __ns1__deleteUser), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteUser(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__deleteUserRequestParameter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__deleteUserRequestParameter(soap, "ns3:deleteUserRequestParameter", &a->ns3__deleteUserRequestParameter, ""))
				{	soap_flag_ns3__deleteUserRequestParameter--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__deleteUser * SOAP_FMAC4 soap_new___ns1__deleteUser(struct soap *soap, int n)
{
	struct __ns1__deleteUser *p;
	struct __ns1__deleteUser *a = (struct __ns1__deleteUser*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__deleteUser));
	for (p = a; p && n--; p++)
		soap_default___ns1__deleteUser(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteUser(struct soap *soap, const struct __ns1__deleteUser *a, const char *tag, const char *type)
{
	if (soap_out___ns1__deleteUser(soap, tag ? tag : "-ns1:deleteUser", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteUser * SOAP_FMAC4 soap_get___ns1__deleteUser(struct soap *soap, struct __ns1__deleteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteUserResponse(struct soap *soap, struct __ns1__deleteUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteUserResponse(struct soap *soap, const struct __ns1__deleteUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteUserResponse(struct soap *soap, const char *tag, int id, const struct __ns1__deleteUserResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteUserResponse * SOAP_FMAC4 soap_in___ns1__deleteUserResponse(struct soap *soap, const char *tag, struct __ns1__deleteUserResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__deleteUserResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteUserResponse, sizeof(struct __ns1__deleteUserResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteUserResponse(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC3 struct __ns1__deleteUserResponse * SOAP_FMAC4 soap_new___ns1__deleteUserResponse(struct soap *soap, int n)
{
	struct __ns1__deleteUserResponse *p;
	struct __ns1__deleteUserResponse *a = (struct __ns1__deleteUserResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__deleteUserResponse));
	for (p = a; p && n--; p++)
		soap_default___ns1__deleteUserResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteUserResponse(struct soap *soap, const struct __ns1__deleteUserResponse *a, const char *tag, const char *type)
{
	if (soap_out___ns1__deleteUserResponse(soap, tag ? tag : "-ns1:deleteUserResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteUserResponse * SOAP_FMAC4 soap_get___ns1__deleteUserResponse(struct soap *soap, struct __ns1__deleteUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__createUser(struct soap *soap, struct __ns1__createUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__createUserRequestParameter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__createUser(struct soap *soap, const struct __ns1__createUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__createUserRequestParameter(soap, &a->ns3__createUserRequestParameter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__createUser(struct soap *soap, const char *tag, int id, const struct __ns1__createUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__createUserRequestParameter(soap, "ns3:createUserRequestParameter", -1, &a->ns3__createUserRequestParameter, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createUser * SOAP_FMAC4 soap_in___ns1__createUser(struct soap *soap, const char *tag, struct __ns1__createUser *a, const char *type)
{
	size_t soap_flag_ns3__createUserRequestParameter = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__createUser *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__createUser, sizeof(struct __ns1__createUser), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__createUser(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__createUserRequestParameter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__createUserRequestParameter(soap, "ns3:createUserRequestParameter", &a->ns3__createUserRequestParameter, ""))
				{	soap_flag_ns3__createUserRequestParameter--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__createUser * SOAP_FMAC4 soap_new___ns1__createUser(struct soap *soap, int n)
{
	struct __ns1__createUser *p;
	struct __ns1__createUser *a = (struct __ns1__createUser*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__createUser));
	for (p = a; p && n--; p++)
		soap_default___ns1__createUser(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__createUser(struct soap *soap, const struct __ns1__createUser *a, const char *tag, const char *type)
{
	if (soap_out___ns1__createUser(soap, tag ? tag : "-ns1:createUser", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createUser * SOAP_FMAC4 soap_get___ns1__createUser(struct soap *soap, struct __ns1__createUser *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__createUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Logout(struct soap *soap, struct __ns1__Logout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__LogoutRequestParameter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Logout(struct soap *soap, const struct __ns1__Logout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__LogoutRequestParameter(soap, &a->ns3__LogoutRequestParameter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Logout(struct soap *soap, const char *tag, int id, const struct __ns1__Logout *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__LogoutRequestParameter(soap, "ns3:LogoutRequestParameter", -1, &a->ns3__LogoutRequestParameter, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Logout * SOAP_FMAC4 soap_in___ns1__Logout(struct soap *soap, const char *tag, struct __ns1__Logout *a, const char *type)
{
	size_t soap_flag_ns3__LogoutRequestParameter = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Logout *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Logout, sizeof(struct __ns1__Logout), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Logout(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__LogoutRequestParameter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__LogoutRequestParameter(soap, "ns3:LogoutRequestParameter", &a->ns3__LogoutRequestParameter, ""))
				{	soap_flag_ns3__LogoutRequestParameter--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__Logout * SOAP_FMAC4 soap_new___ns1__Logout(struct soap *soap, int n)
{
	struct __ns1__Logout *p;
	struct __ns1__Logout *a = (struct __ns1__Logout*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__Logout));
	for (p = a; p && n--; p++)
		soap_default___ns1__Logout(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Logout(struct soap *soap, const struct __ns1__Logout *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Logout(soap, tag ? tag : "-ns1:Logout", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Logout * SOAP_FMAC4 soap_get___ns1__Logout(struct soap *soap, struct __ns1__Logout *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Logout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__LogoutResponse(struct soap *soap, struct __ns1__LogoutResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__LogoutResponse(struct soap *soap, const struct __ns1__LogoutResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__LogoutResponse(struct soap *soap, const char *tag, int id, const struct __ns1__LogoutResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LogoutResponse * SOAP_FMAC4 soap_in___ns1__LogoutResponse(struct soap *soap, const char *tag, struct __ns1__LogoutResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__LogoutResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__LogoutResponse, sizeof(struct __ns1__LogoutResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__LogoutResponse(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC3 struct __ns1__LogoutResponse * SOAP_FMAC4 soap_new___ns1__LogoutResponse(struct soap *soap, int n)
{
	struct __ns1__LogoutResponse *p;
	struct __ns1__LogoutResponse *a = (struct __ns1__LogoutResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__LogoutResponse));
	for (p = a; p && n--; p++)
		soap_default___ns1__LogoutResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__LogoutResponse(struct soap *soap, const struct __ns1__LogoutResponse *a, const char *tag, const char *type)
{
	if (soap_out___ns1__LogoutResponse(soap, tag ? tag : "-ns1:LogoutResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LogoutResponse * SOAP_FMAC4 soap_get___ns1__LogoutResponse(struct soap *soap, struct __ns1__LogoutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__LogoutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__LoginImpersonate(struct soap *soap, struct __ns1__LoginImpersonate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__LoginImpersonateRequestParameter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__LoginImpersonate(struct soap *soap, const struct __ns1__LoginImpersonate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__LoginImpersonateRequestParameter(soap, &a->ns3__LoginImpersonateRequestParameter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__LoginImpersonate(struct soap *soap, const char *tag, int id, const struct __ns1__LoginImpersonate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__LoginImpersonateRequestParameter(soap, "ns3:LoginImpersonateRequestParameter", -1, &a->ns3__LoginImpersonateRequestParameter, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LoginImpersonate * SOAP_FMAC4 soap_in___ns1__LoginImpersonate(struct soap *soap, const char *tag, struct __ns1__LoginImpersonate *a, const char *type)
{
	size_t soap_flag_ns3__LoginImpersonateRequestParameter = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__LoginImpersonate *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__LoginImpersonate, sizeof(struct __ns1__LoginImpersonate), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__LoginImpersonate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__LoginImpersonateRequestParameter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__LoginImpersonateRequestParameter(soap, "ns3:LoginImpersonateRequestParameter", &a->ns3__LoginImpersonateRequestParameter, ""))
				{	soap_flag_ns3__LoginImpersonateRequestParameter--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__LoginImpersonate * SOAP_FMAC4 soap_new___ns1__LoginImpersonate(struct soap *soap, int n)
{
	struct __ns1__LoginImpersonate *p;
	struct __ns1__LoginImpersonate *a = (struct __ns1__LoginImpersonate*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__LoginImpersonate));
	for (p = a; p && n--; p++)
		soap_default___ns1__LoginImpersonate(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__LoginImpersonate(struct soap *soap, const struct __ns1__LoginImpersonate *a, const char *tag, const char *type)
{
	if (soap_out___ns1__LoginImpersonate(soap, tag ? tag : "-ns1:LoginImpersonate", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LoginImpersonate * SOAP_FMAC4 soap_get___ns1__LoginImpersonate(struct soap *soap, struct __ns1__LoginImpersonate *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__LoginImpersonate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__LoginSAML(struct soap *soap, struct __ns1__LoginSAML *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__LoginSAMLRequestParameter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__LoginSAML(struct soap *soap, const struct __ns1__LoginSAML *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__LoginSAMLRequestParameter(soap, &a->ns3__LoginSAMLRequestParameter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__LoginSAML(struct soap *soap, const char *tag, int id, const struct __ns1__LoginSAML *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__LoginSAMLRequestParameter(soap, "ns3:LoginSAMLRequestParameter", -1, &a->ns3__LoginSAMLRequestParameter, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LoginSAML * SOAP_FMAC4 soap_in___ns1__LoginSAML(struct soap *soap, const char *tag, struct __ns1__LoginSAML *a, const char *type)
{
	size_t soap_flag_ns3__LoginSAMLRequestParameter = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__LoginSAML *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__LoginSAML, sizeof(struct __ns1__LoginSAML), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__LoginSAML(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__LoginSAMLRequestParameter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__LoginSAMLRequestParameter(soap, "ns3:LoginSAMLRequestParameter", &a->ns3__LoginSAMLRequestParameter, ""))
				{	soap_flag_ns3__LoginSAMLRequestParameter--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__LoginSAML * SOAP_FMAC4 soap_new___ns1__LoginSAML(struct soap *soap, int n)
{
	struct __ns1__LoginSAML *p;
	struct __ns1__LoginSAML *a = (struct __ns1__LoginSAML*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__LoginSAML));
	for (p = a; p && n--; p++)
		soap_default___ns1__LoginSAML(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__LoginSAML(struct soap *soap, const struct __ns1__LoginSAML *a, const char *tag, const char *type)
{
	if (soap_out___ns1__LoginSAML(soap, tag ? tag : "-ns1:LoginSAML", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LoginSAML * SOAP_FMAC4 soap_get___ns1__LoginSAML(struct soap *soap, struct __ns1__LoginSAML *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__LoginSAML(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__LoginNoAuth(struct soap *soap, struct __ns1__LoginNoAuth *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__LoginNoAuthRequestParameter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__LoginNoAuth(struct soap *soap, const struct __ns1__LoginNoAuth *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__LoginNoAuthRequestParameter(soap, &a->ns3__LoginNoAuthRequestParameter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__LoginNoAuth(struct soap *soap, const char *tag, int id, const struct __ns1__LoginNoAuth *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__LoginNoAuthRequestParameter(soap, "ns3:LoginNoAuthRequestParameter", -1, &a->ns3__LoginNoAuthRequestParameter, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LoginNoAuth * SOAP_FMAC4 soap_in___ns1__LoginNoAuth(struct soap *soap, const char *tag, struct __ns1__LoginNoAuth *a, const char *type)
{
	size_t soap_flag_ns3__LoginNoAuthRequestParameter = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__LoginNoAuth *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__LoginNoAuth, sizeof(struct __ns1__LoginNoAuth), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__LoginNoAuth(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__LoginNoAuthRequestParameter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__LoginNoAuthRequestParameter(soap, "ns3:LoginNoAuthRequestParameter", &a->ns3__LoginNoAuthRequestParameter, ""))
				{	soap_flag_ns3__LoginNoAuthRequestParameter--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__LoginNoAuth * SOAP_FMAC4 soap_new___ns1__LoginNoAuth(struct soap *soap, int n)
{
	struct __ns1__LoginNoAuth *p;
	struct __ns1__LoginNoAuth *a = (struct __ns1__LoginNoAuth*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__LoginNoAuth));
	for (p = a; p && n--; p++)
		soap_default___ns1__LoginNoAuth(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__LoginNoAuth(struct soap *soap, const struct __ns1__LoginNoAuth *a, const char *tag, const char *type)
{
	if (soap_out___ns1__LoginNoAuth(soap, tag ? tag : "-ns1:LoginNoAuth", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LoginNoAuth * SOAP_FMAC4 soap_get___ns1__LoginNoAuth(struct soap *soap, struct __ns1__LoginNoAuth *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__LoginNoAuth(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Login(struct soap *soap, struct __ns1__Login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__LoginRequestParameter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Login(struct soap *soap, const struct __ns1__Login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__LoginRequestParameter(soap, &a->ns3__LoginRequestParameter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Login(struct soap *soap, const char *tag, int id, const struct __ns1__Login *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__LoginRequestParameter(soap, "ns3:LoginRequestParameter", -1, &a->ns3__LoginRequestParameter, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Login * SOAP_FMAC4 soap_in___ns1__Login(struct soap *soap, const char *tag, struct __ns1__Login *a, const char *type)
{
	size_t soap_flag_ns3__LoginRequestParameter = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Login *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Login, sizeof(struct __ns1__Login), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Login(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__LoginRequestParameter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__LoginRequestParameter(soap, "ns3:LoginRequestParameter", &a->ns3__LoginRequestParameter, ""))
				{	soap_flag_ns3__LoginRequestParameter--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__Login * SOAP_FMAC4 soap_new___ns1__Login(struct soap *soap, int n)
{
	struct __ns1__Login *p;
	struct __ns1__Login *a = (struct __ns1__Login*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__Login));
	for (p = a; p && n--; p++)
		soap_default___ns1__Login(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Login(struct soap *soap, const struct __ns1__Login *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Login(soap, tag ? tag : "-ns1:Login", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Login * SOAP_FMAC4 soap_get___ns1__Login(struct soap *soap, struct __ns1__Login *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__AssertionException = NULL;
	a->ns2__GeneralWebserviceException = NULL;
	a->ns2__ImpersonatedUserNotFoundException = NULL;
	a->ns2__InvalidClientException = NULL;
	a->ns2__InvalidConcurrentLicenseException = NULL;
	a->ns2__InvalidDatesException = NULL;
	a->ns2__InvalidNamedLicenseException = NULL;
	a->ns2__InvalidNrOfImpersonationsException = NULL;
	a->ns2__InvalidParameterException = NULL;
	a->ns2__InvalidSessionException = NULL;
	a->ns2__InvalidUsernameException = NULL;
	a->ns2__InvalidUsernamePasswordCombinationException = NULL;
	a->ns2__PermissionDeniedException = NULL;
	a->ns2__ServerMaintenanceException = NULL;
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns2__AssertionException(soap, &a->ns2__AssertionException);
	soap_serialize_PointerTo_ns2__GeneralWebserviceException(soap, &a->ns2__GeneralWebserviceException);
	soap_serialize_PointerTo_ns2__ImpersonatedUserNotFoundException(soap, &a->ns2__ImpersonatedUserNotFoundException);
	soap_serialize_PointerTo_ns2__InvalidClientException(soap, &a->ns2__InvalidClientException);
	soap_serialize_PointerTo_ns2__InvalidConcurrentLicenseException(soap, &a->ns2__InvalidConcurrentLicenseException);
	soap_serialize_PointerTo_ns2__InvalidDatesException(soap, &a->ns2__InvalidDatesException);
	soap_serialize_PointerTo_ns2__InvalidNamedLicenseException(soap, &a->ns2__InvalidNamedLicenseException);
	soap_serialize_PointerTo_ns2__InvalidNrOfImpersonationsException(soap, &a->ns2__InvalidNrOfImpersonationsException);
	soap_serialize_PointerTo_ns2__InvalidParameterException(soap, &a->ns2__InvalidParameterException);
	soap_serialize_PointerTo_ns2__InvalidSessionException(soap, &a->ns2__InvalidSessionException);
	soap_serialize_PointerTo_ns2__InvalidUsernameException(soap, &a->ns2__InvalidUsernameException);
	soap_serialize_PointerTo_ns2__InvalidUsernamePasswordCombinationException(soap, &a->ns2__InvalidUsernamePasswordCombinationException);
	soap_serialize_PointerTo_ns2__PermissionDeniedException(soap, &a->ns2__PermissionDeniedException);
	soap_serialize_PointerTo_ns2__ServerMaintenanceException(soap, &a->ns2__ServerMaintenanceException);
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_out_PointerTo_ns2__AssertionException(soap, "ns2:AssertionException", -1, &a->ns2__AssertionException, ""))
		return soap->error;
	if (soap_out_PointerTo_ns2__GeneralWebserviceException(soap, "ns2:GeneralWebserviceException", -1, &a->ns2__GeneralWebserviceException, ""))
		return soap->error;
	if (soap_out_PointerTo_ns2__ImpersonatedUserNotFoundException(soap, "ns2:ImpersonatedUserNotFoundException", -1, &a->ns2__ImpersonatedUserNotFoundException, ""))
		return soap->error;
	if (soap_out_PointerTo_ns2__InvalidClientException(soap, "ns2:InvalidClientException", -1, &a->ns2__InvalidClientException, ""))
		return soap->error;
	if (soap_out_PointerTo_ns2__InvalidConcurrentLicenseException(soap, "ns2:InvalidConcurrentLicenseException", -1, &a->ns2__InvalidConcurrentLicenseException, ""))
		return soap->error;
	if (soap_out_PointerTo_ns2__InvalidDatesException(soap, "ns2:InvalidDatesException", -1, &a->ns2__InvalidDatesException, ""))
		return soap->error;
	if (soap_out_PointerTo_ns2__InvalidNamedLicenseException(soap, "ns2:InvalidNamedLicenseException", -1, &a->ns2__InvalidNamedLicenseException, ""))
		return soap->error;
	if (soap_out_PointerTo_ns2__InvalidNrOfImpersonationsException(soap, "ns2:InvalidNrOfImpersonationsException", -1, &a->ns2__InvalidNrOfImpersonationsException, ""))
		return soap->error;
	if (soap_out_PointerTo_ns2__InvalidParameterException(soap, "ns2:InvalidParameterException", -1, &a->ns2__InvalidParameterException, ""))
		return soap->error;
	if (soap_out_PointerTo_ns2__InvalidSessionException(soap, "ns2:InvalidSessionException", -1, &a->ns2__InvalidSessionException, ""))
		return soap->error;
	if (soap_out_PointerTo_ns2__InvalidUsernameException(soap, "ns2:InvalidUsernameException", -1, &a->ns2__InvalidUsernameException, ""))
		return soap->error;
	if (soap_out_PointerTo_ns2__InvalidUsernamePasswordCombinationException(soap, "ns2:InvalidUsernamePasswordCombinationException", -1, &a->ns2__InvalidUsernamePasswordCombinationException, ""))
		return soap->error;
	if (soap_out_PointerTo_ns2__PermissionDeniedException(soap, "ns2:PermissionDeniedException", -1, &a->ns2__PermissionDeniedException, ""))
		return soap->error;
	if (soap_out_PointerTo_ns2__ServerMaintenanceException(soap, "ns2:ServerMaintenanceException", -1, &a->ns2__ServerMaintenanceException, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_ns2__AssertionException = 1;
	size_t soap_flag_ns2__GeneralWebserviceException = 1;
	size_t soap_flag_ns2__ImpersonatedUserNotFoundException = 1;
	size_t soap_flag_ns2__InvalidClientException = 1;
	size_t soap_flag_ns2__InvalidConcurrentLicenseException = 1;
	size_t soap_flag_ns2__InvalidDatesException = 1;
	size_t soap_flag_ns2__InvalidNamedLicenseException = 1;
	size_t soap_flag_ns2__InvalidNrOfImpersonationsException = 1;
	size_t soap_flag_ns2__InvalidParameterException = 1;
	size_t soap_flag_ns2__InvalidSessionException = 1;
	size_t soap_flag_ns2__InvalidUsernameException = 1;
	size_t soap_flag_ns2__InvalidUsernamePasswordCombinationException = 1;
	size_t soap_flag_ns2__PermissionDeniedException = 1;
	size_t soap_flag_ns2__ServerMaintenanceException = 1;
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__AssertionException && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns2__AssertionException(soap, "ns2:AssertionException", &a->ns2__AssertionException, ""))
				{	soap_flag_ns2__AssertionException--;
					continue;
				}
			}
			if (soap_flag_ns2__GeneralWebserviceException && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns2__GeneralWebserviceException(soap, "ns2:GeneralWebserviceException", &a->ns2__GeneralWebserviceException, ""))
				{	soap_flag_ns2__GeneralWebserviceException--;
					continue;
				}
			}
			if (soap_flag_ns2__ImpersonatedUserNotFoundException && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns2__ImpersonatedUserNotFoundException(soap, "ns2:ImpersonatedUserNotFoundException", &a->ns2__ImpersonatedUserNotFoundException, ""))
				{	soap_flag_ns2__ImpersonatedUserNotFoundException--;
					continue;
				}
			}
			if (soap_flag_ns2__InvalidClientException && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns2__InvalidClientException(soap, "ns2:InvalidClientException", &a->ns2__InvalidClientException, ""))
				{	soap_flag_ns2__InvalidClientException--;
					continue;
				}
			}
			if (soap_flag_ns2__InvalidConcurrentLicenseException && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns2__InvalidConcurrentLicenseException(soap, "ns2:InvalidConcurrentLicenseException", &a->ns2__InvalidConcurrentLicenseException, ""))
				{	soap_flag_ns2__InvalidConcurrentLicenseException--;
					continue;
				}
			}
			if (soap_flag_ns2__InvalidDatesException && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns2__InvalidDatesException(soap, "ns2:InvalidDatesException", &a->ns2__InvalidDatesException, ""))
				{	soap_flag_ns2__InvalidDatesException--;
					continue;
				}
			}
			if (soap_flag_ns2__InvalidNamedLicenseException && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns2__InvalidNamedLicenseException(soap, "ns2:InvalidNamedLicenseException", &a->ns2__InvalidNamedLicenseException, ""))
				{	soap_flag_ns2__InvalidNamedLicenseException--;
					continue;
				}
			}
			if (soap_flag_ns2__InvalidNrOfImpersonationsException && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns2__InvalidNrOfImpersonationsException(soap, "ns2:InvalidNrOfImpersonationsException", &a->ns2__InvalidNrOfImpersonationsException, ""))
				{	soap_flag_ns2__InvalidNrOfImpersonationsException--;
					continue;
				}
			}
			if (soap_flag_ns2__InvalidParameterException && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns2__InvalidParameterException(soap, "ns2:InvalidParameterException", &a->ns2__InvalidParameterException, ""))
				{	soap_flag_ns2__InvalidParameterException--;
					continue;
				}
			}
			if (soap_flag_ns2__InvalidSessionException && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns2__InvalidSessionException(soap, "ns2:InvalidSessionException", &a->ns2__InvalidSessionException, ""))
				{	soap_flag_ns2__InvalidSessionException--;
					continue;
				}
			}
			if (soap_flag_ns2__InvalidUsernameException && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns2__InvalidUsernameException(soap, "ns2:InvalidUsernameException", &a->ns2__InvalidUsernameException, ""))
				{	soap_flag_ns2__InvalidUsernameException--;
					continue;
				}
			}
			if (soap_flag_ns2__InvalidUsernamePasswordCombinationException && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns2__InvalidUsernamePasswordCombinationException(soap, "ns2:InvalidUsernamePasswordCombinationException", &a->ns2__InvalidUsernamePasswordCombinationException, ""))
				{	soap_flag_ns2__InvalidUsernamePasswordCombinationException--;
					continue;
				}
			}
			if (soap_flag_ns2__PermissionDeniedException && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns2__PermissionDeniedException(soap, "ns2:PermissionDeniedException", &a->ns2__PermissionDeniedException, ""))
				{	soap_flag_ns2__PermissionDeniedException--;
					continue;
				}
			}
			if (soap_flag_ns2__ServerMaintenanceException && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns2__ServerMaintenanceException(soap, "ns2:ServerMaintenanceException", &a->ns2__ServerMaintenanceException, ""))
				{	soap_flag_ns2__ServerMaintenanceException--;
					continue;
				}
			}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{
	struct SOAP_ENV__Detail *p;
	struct SOAP_ENV__Detail *a = (struct SOAP_ENV__Detail*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Detail));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Detail(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__InvalidConcurrentLicenseException(struct soap *soap, struct _ns2__InvalidConcurrentLicenseException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cause = NULL;
	soap_default_string(soap, &a->message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__InvalidConcurrentLicenseException(struct soap *soap, const struct _ns2__InvalidConcurrentLicenseException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->message);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__InvalidConcurrentLicenseException(struct soap *soap, const char *tag, int id, const struct _ns2__InvalidConcurrentLicenseException *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__InvalidConcurrentLicenseException), type))
		return soap->error;
	if (!a->cause)
	{	if (soap_element_nil(soap, "ns2:cause"))
			return soap->error;
	}
	else
	if (soap_outliteral(soap, "ns2:cause", (char*const*)&a->cause, NULL))
		return soap->error;
	if (!a->message)
	{	if (soap_element_nil(soap, "ns2:message"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns2:message", -1, (char*const*)&a->message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__InvalidConcurrentLicenseException * SOAP_FMAC4 soap_in__ns2__InvalidConcurrentLicenseException(struct soap *soap, const char *tag, struct _ns2__InvalidConcurrentLicenseException *a, const char *type)
{
	size_t soap_flag_cause = 1;
	size_t soap_flag_message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__InvalidConcurrentLicenseException *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__InvalidConcurrentLicenseException, sizeof(struct _ns2__InvalidConcurrentLicenseException), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__InvalidConcurrentLicenseException(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cause && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "ns2:cause", (char**)&a->cause))
				{	soap_flag_cause--;
					continue;
				}
			}
			if (soap_flag_message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns2:message", (char**)&a->message, "xsd:string"))
				{	soap_flag_message--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cause > 0 || soap_flag_message > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns2__InvalidConcurrentLicenseException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__InvalidConcurrentLicenseException, SOAP_TYPE__ns2__InvalidConcurrentLicenseException, sizeof(struct _ns2__InvalidConcurrentLicenseException), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns2__InvalidConcurrentLicenseException * SOAP_FMAC4 soap_new__ns2__InvalidConcurrentLicenseException(struct soap *soap, int n)
{
	struct _ns2__InvalidConcurrentLicenseException *p;
	struct _ns2__InvalidConcurrentLicenseException *a = (struct _ns2__InvalidConcurrentLicenseException*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns2__InvalidConcurrentLicenseException));
	for (p = a; p && n--; p++)
		soap_default__ns2__InvalidConcurrentLicenseException(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__InvalidConcurrentLicenseException(struct soap *soap, const struct _ns2__InvalidConcurrentLicenseException *a, const char *tag, const char *type)
{
	if (soap_out__ns2__InvalidConcurrentLicenseException(soap, tag ? tag : "ns2:InvalidConcurrentLicenseException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__InvalidConcurrentLicenseException * SOAP_FMAC4 soap_get__ns2__InvalidConcurrentLicenseException(struct soap *soap, struct _ns2__InvalidConcurrentLicenseException *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__InvalidConcurrentLicenseException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__InvalidNamedLicenseException(struct soap *soap, struct _ns2__InvalidNamedLicenseException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cause = NULL;
	soap_default_string(soap, &a->message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__InvalidNamedLicenseException(struct soap *soap, const struct _ns2__InvalidNamedLicenseException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->message);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__InvalidNamedLicenseException(struct soap *soap, const char *tag, int id, const struct _ns2__InvalidNamedLicenseException *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__InvalidNamedLicenseException), type))
		return soap->error;
	if (!a->cause)
	{	if (soap_element_nil(soap, "ns2:cause"))
			return soap->error;
	}
	else
	if (soap_outliteral(soap, "ns2:cause", (char*const*)&a->cause, NULL))
		return soap->error;
	if (!a->message)
	{	if (soap_element_nil(soap, "ns2:message"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns2:message", -1, (char*const*)&a->message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__InvalidNamedLicenseException * SOAP_FMAC4 soap_in__ns2__InvalidNamedLicenseException(struct soap *soap, const char *tag, struct _ns2__InvalidNamedLicenseException *a, const char *type)
{
	size_t soap_flag_cause = 1;
	size_t soap_flag_message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__InvalidNamedLicenseException *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__InvalidNamedLicenseException, sizeof(struct _ns2__InvalidNamedLicenseException), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__InvalidNamedLicenseException(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cause && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "ns2:cause", (char**)&a->cause))
				{	soap_flag_cause--;
					continue;
				}
			}
			if (soap_flag_message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns2:message", (char**)&a->message, "xsd:string"))
				{	soap_flag_message--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cause > 0 || soap_flag_message > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns2__InvalidNamedLicenseException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__InvalidNamedLicenseException, SOAP_TYPE__ns2__InvalidNamedLicenseException, sizeof(struct _ns2__InvalidNamedLicenseException), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns2__InvalidNamedLicenseException * SOAP_FMAC4 soap_new__ns2__InvalidNamedLicenseException(struct soap *soap, int n)
{
	struct _ns2__InvalidNamedLicenseException *p;
	struct _ns2__InvalidNamedLicenseException *a = (struct _ns2__InvalidNamedLicenseException*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns2__InvalidNamedLicenseException));
	for (p = a; p && n--; p++)
		soap_default__ns2__InvalidNamedLicenseException(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__InvalidNamedLicenseException(struct soap *soap, const struct _ns2__InvalidNamedLicenseException *a, const char *tag, const char *type)
{
	if (soap_out__ns2__InvalidNamedLicenseException(soap, tag ? tag : "ns2:InvalidNamedLicenseException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__InvalidNamedLicenseException * SOAP_FMAC4 soap_get__ns2__InvalidNamedLicenseException(struct soap *soap, struct _ns2__InvalidNamedLicenseException *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__InvalidNamedLicenseException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__InvalidNrOfImpersonationsException(struct soap *soap, struct _ns2__InvalidNrOfImpersonationsException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cause = NULL;
	soap_default_string(soap, &a->message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__InvalidNrOfImpersonationsException(struct soap *soap, const struct _ns2__InvalidNrOfImpersonationsException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->message);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__InvalidNrOfImpersonationsException(struct soap *soap, const char *tag, int id, const struct _ns2__InvalidNrOfImpersonationsException *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__InvalidNrOfImpersonationsException), type))
		return soap->error;
	if (!a->cause)
	{	if (soap_element_nil(soap, "ns2:cause"))
			return soap->error;
	}
	else
	if (soap_outliteral(soap, "ns2:cause", (char*const*)&a->cause, NULL))
		return soap->error;
	if (!a->message)
	{	if (soap_element_nil(soap, "ns2:message"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns2:message", -1, (char*const*)&a->message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__InvalidNrOfImpersonationsException * SOAP_FMAC4 soap_in__ns2__InvalidNrOfImpersonationsException(struct soap *soap, const char *tag, struct _ns2__InvalidNrOfImpersonationsException *a, const char *type)
{
	size_t soap_flag_cause = 1;
	size_t soap_flag_message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__InvalidNrOfImpersonationsException *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__InvalidNrOfImpersonationsException, sizeof(struct _ns2__InvalidNrOfImpersonationsException), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__InvalidNrOfImpersonationsException(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cause && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "ns2:cause", (char**)&a->cause))
				{	soap_flag_cause--;
					continue;
				}
			}
			if (soap_flag_message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns2:message", (char**)&a->message, "xsd:string"))
				{	soap_flag_message--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cause > 0 || soap_flag_message > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns2__InvalidNrOfImpersonationsException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__InvalidNrOfImpersonationsException, SOAP_TYPE__ns2__InvalidNrOfImpersonationsException, sizeof(struct _ns2__InvalidNrOfImpersonationsException), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns2__InvalidNrOfImpersonationsException * SOAP_FMAC4 soap_new__ns2__InvalidNrOfImpersonationsException(struct soap *soap, int n)
{
	struct _ns2__InvalidNrOfImpersonationsException *p;
	struct _ns2__InvalidNrOfImpersonationsException *a = (struct _ns2__InvalidNrOfImpersonationsException*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns2__InvalidNrOfImpersonationsException));
	for (p = a; p && n--; p++)
		soap_default__ns2__InvalidNrOfImpersonationsException(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__InvalidNrOfImpersonationsException(struct soap *soap, const struct _ns2__InvalidNrOfImpersonationsException *a, const char *tag, const char *type)
{
	if (soap_out__ns2__InvalidNrOfImpersonationsException(soap, tag ? tag : "ns2:InvalidNrOfImpersonationsException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__InvalidNrOfImpersonationsException * SOAP_FMAC4 soap_get__ns2__InvalidNrOfImpersonationsException(struct soap *soap, struct _ns2__InvalidNrOfImpersonationsException *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__InvalidNrOfImpersonationsException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__ImpersonatedUserNotFoundException(struct soap *soap, struct _ns2__ImpersonatedUserNotFoundException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cause = NULL;
	soap_default_string(soap, &a->message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__ImpersonatedUserNotFoundException(struct soap *soap, const struct _ns2__ImpersonatedUserNotFoundException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->message);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__ImpersonatedUserNotFoundException(struct soap *soap, const char *tag, int id, const struct _ns2__ImpersonatedUserNotFoundException *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__ImpersonatedUserNotFoundException), type))
		return soap->error;
	if (!a->cause)
	{	if (soap_element_nil(soap, "ns2:cause"))
			return soap->error;
	}
	else
	if (soap_outliteral(soap, "ns2:cause", (char*const*)&a->cause, NULL))
		return soap->error;
	if (!a->message)
	{	if (soap_element_nil(soap, "ns2:message"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns2:message", -1, (char*const*)&a->message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__ImpersonatedUserNotFoundException * SOAP_FMAC4 soap_in__ns2__ImpersonatedUserNotFoundException(struct soap *soap, const char *tag, struct _ns2__ImpersonatedUserNotFoundException *a, const char *type)
{
	size_t soap_flag_cause = 1;
	size_t soap_flag_message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__ImpersonatedUserNotFoundException *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__ImpersonatedUserNotFoundException, sizeof(struct _ns2__ImpersonatedUserNotFoundException), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__ImpersonatedUserNotFoundException(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cause && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "ns2:cause", (char**)&a->cause))
				{	soap_flag_cause--;
					continue;
				}
			}
			if (soap_flag_message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns2:message", (char**)&a->message, "xsd:string"))
				{	soap_flag_message--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cause > 0 || soap_flag_message > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns2__ImpersonatedUserNotFoundException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__ImpersonatedUserNotFoundException, SOAP_TYPE__ns2__ImpersonatedUserNotFoundException, sizeof(struct _ns2__ImpersonatedUserNotFoundException), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns2__ImpersonatedUserNotFoundException * SOAP_FMAC4 soap_new__ns2__ImpersonatedUserNotFoundException(struct soap *soap, int n)
{
	struct _ns2__ImpersonatedUserNotFoundException *p;
	struct _ns2__ImpersonatedUserNotFoundException *a = (struct _ns2__ImpersonatedUserNotFoundException*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns2__ImpersonatedUserNotFoundException));
	for (p = a; p && n--; p++)
		soap_default__ns2__ImpersonatedUserNotFoundException(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__ImpersonatedUserNotFoundException(struct soap *soap, const struct _ns2__ImpersonatedUserNotFoundException *a, const char *tag, const char *type)
{
	if (soap_out__ns2__ImpersonatedUserNotFoundException(soap, tag ? tag : "ns2:ImpersonatedUserNotFoundException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__ImpersonatedUserNotFoundException * SOAP_FMAC4 soap_get__ns2__ImpersonatedUserNotFoundException(struct soap *soap, struct _ns2__ImpersonatedUserNotFoundException *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__ImpersonatedUserNotFoundException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__ServerMaintenanceException(struct soap *soap, struct _ns2__ServerMaintenanceException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cause = NULL;
	soap_default_string(soap, &a->message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__ServerMaintenanceException(struct soap *soap, const struct _ns2__ServerMaintenanceException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->message);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__ServerMaintenanceException(struct soap *soap, const char *tag, int id, const struct _ns2__ServerMaintenanceException *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__ServerMaintenanceException), type))
		return soap->error;
	if (!a->cause)
	{	if (soap_element_nil(soap, "ns2:cause"))
			return soap->error;
	}
	else
	if (soap_outliteral(soap, "ns2:cause", (char*const*)&a->cause, NULL))
		return soap->error;
	if (!a->message)
	{	if (soap_element_nil(soap, "ns2:message"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns2:message", -1, (char*const*)&a->message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__ServerMaintenanceException * SOAP_FMAC4 soap_in__ns2__ServerMaintenanceException(struct soap *soap, const char *tag, struct _ns2__ServerMaintenanceException *a, const char *type)
{
	size_t soap_flag_cause = 1;
	size_t soap_flag_message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__ServerMaintenanceException *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__ServerMaintenanceException, sizeof(struct _ns2__ServerMaintenanceException), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__ServerMaintenanceException(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cause && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "ns2:cause", (char**)&a->cause))
				{	soap_flag_cause--;
					continue;
				}
			}
			if (soap_flag_message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns2:message", (char**)&a->message, "xsd:string"))
				{	soap_flag_message--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cause > 0 || soap_flag_message > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns2__ServerMaintenanceException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__ServerMaintenanceException, SOAP_TYPE__ns2__ServerMaintenanceException, sizeof(struct _ns2__ServerMaintenanceException), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns2__ServerMaintenanceException * SOAP_FMAC4 soap_new__ns2__ServerMaintenanceException(struct soap *soap, int n)
{
	struct _ns2__ServerMaintenanceException *p;
	struct _ns2__ServerMaintenanceException *a = (struct _ns2__ServerMaintenanceException*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns2__ServerMaintenanceException));
	for (p = a; p && n--; p++)
		soap_default__ns2__ServerMaintenanceException(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__ServerMaintenanceException(struct soap *soap, const struct _ns2__ServerMaintenanceException *a, const char *tag, const char *type)
{
	if (soap_out__ns2__ServerMaintenanceException(soap, tag ? tag : "ns2:ServerMaintenanceException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__ServerMaintenanceException * SOAP_FMAC4 soap_get__ns2__ServerMaintenanceException(struct soap *soap, struct _ns2__ServerMaintenanceException *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__ServerMaintenanceException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__InvalidDatesException(struct soap *soap, struct _ns2__InvalidDatesException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cause = NULL;
	soap_default_string(soap, &a->message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__InvalidDatesException(struct soap *soap, const struct _ns2__InvalidDatesException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->message);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__InvalidDatesException(struct soap *soap, const char *tag, int id, const struct _ns2__InvalidDatesException *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__InvalidDatesException), type))
		return soap->error;
	if (!a->cause)
	{	if (soap_element_nil(soap, "ns2:cause"))
			return soap->error;
	}
	else
	if (soap_outliteral(soap, "ns2:cause", (char*const*)&a->cause, NULL))
		return soap->error;
	if (!a->message)
	{	if (soap_element_nil(soap, "ns2:message"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns2:message", -1, (char*const*)&a->message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__InvalidDatesException * SOAP_FMAC4 soap_in__ns2__InvalidDatesException(struct soap *soap, const char *tag, struct _ns2__InvalidDatesException *a, const char *type)
{
	size_t soap_flag_cause = 1;
	size_t soap_flag_message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__InvalidDatesException *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__InvalidDatesException, sizeof(struct _ns2__InvalidDatesException), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__InvalidDatesException(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cause && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "ns2:cause", (char**)&a->cause))
				{	soap_flag_cause--;
					continue;
				}
			}
			if (soap_flag_message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns2:message", (char**)&a->message, "xsd:string"))
				{	soap_flag_message--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cause > 0 || soap_flag_message > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns2__InvalidDatesException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__InvalidDatesException, SOAP_TYPE__ns2__InvalidDatesException, sizeof(struct _ns2__InvalidDatesException), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns2__InvalidDatesException * SOAP_FMAC4 soap_new__ns2__InvalidDatesException(struct soap *soap, int n)
{
	struct _ns2__InvalidDatesException *p;
	struct _ns2__InvalidDatesException *a = (struct _ns2__InvalidDatesException*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns2__InvalidDatesException));
	for (p = a; p && n--; p++)
		soap_default__ns2__InvalidDatesException(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__InvalidDatesException(struct soap *soap, const struct _ns2__InvalidDatesException *a, const char *tag, const char *type)
{
	if (soap_out__ns2__InvalidDatesException(soap, tag ? tag : "ns2:InvalidDatesException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__InvalidDatesException * SOAP_FMAC4 soap_get__ns2__InvalidDatesException(struct soap *soap, struct _ns2__InvalidDatesException *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__InvalidDatesException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__InvalidUsernameException(struct soap *soap, struct _ns2__InvalidUsernameException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cause = NULL;
	soap_default_string(soap, &a->message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__InvalidUsernameException(struct soap *soap, const struct _ns2__InvalidUsernameException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->message);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__InvalidUsernameException(struct soap *soap, const char *tag, int id, const struct _ns2__InvalidUsernameException *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__InvalidUsernameException), type))
		return soap->error;
	if (!a->cause)
	{	if (soap_element_nil(soap, "ns2:cause"))
			return soap->error;
	}
	else
	if (soap_outliteral(soap, "ns2:cause", (char*const*)&a->cause, NULL))
		return soap->error;
	if (!a->message)
	{	if (soap_element_nil(soap, "ns2:message"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns2:message", -1, (char*const*)&a->message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__InvalidUsernameException * SOAP_FMAC4 soap_in__ns2__InvalidUsernameException(struct soap *soap, const char *tag, struct _ns2__InvalidUsernameException *a, const char *type)
{
	size_t soap_flag_cause = 1;
	size_t soap_flag_message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__InvalidUsernameException *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__InvalidUsernameException, sizeof(struct _ns2__InvalidUsernameException), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__InvalidUsernameException(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cause && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "ns2:cause", (char**)&a->cause))
				{	soap_flag_cause--;
					continue;
				}
			}
			if (soap_flag_message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns2:message", (char**)&a->message, "xsd:string"))
				{	soap_flag_message--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cause > 0 || soap_flag_message > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns2__InvalidUsernameException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__InvalidUsernameException, SOAP_TYPE__ns2__InvalidUsernameException, sizeof(struct _ns2__InvalidUsernameException), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns2__InvalidUsernameException * SOAP_FMAC4 soap_new__ns2__InvalidUsernameException(struct soap *soap, int n)
{
	struct _ns2__InvalidUsernameException *p;
	struct _ns2__InvalidUsernameException *a = (struct _ns2__InvalidUsernameException*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns2__InvalidUsernameException));
	for (p = a; p && n--; p++)
		soap_default__ns2__InvalidUsernameException(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__InvalidUsernameException(struct soap *soap, const struct _ns2__InvalidUsernameException *a, const char *tag, const char *type)
{
	if (soap_out__ns2__InvalidUsernameException(soap, tag ? tag : "ns2:InvalidUsernameException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__InvalidUsernameException * SOAP_FMAC4 soap_get__ns2__InvalidUsernameException(struct soap *soap, struct _ns2__InvalidUsernameException *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__InvalidUsernameException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__InvalidUsernamePasswordCombinationException(struct soap *soap, struct _ns2__InvalidUsernamePasswordCombinationException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cause = NULL;
	soap_default_string(soap, &a->message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__InvalidUsernamePasswordCombinationException(struct soap *soap, const struct _ns2__InvalidUsernamePasswordCombinationException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->message);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__InvalidUsernamePasswordCombinationException(struct soap *soap, const char *tag, int id, const struct _ns2__InvalidUsernamePasswordCombinationException *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__InvalidUsernamePasswordCombinationException), type))
		return soap->error;
	if (!a->cause)
	{	if (soap_element_nil(soap, "ns2:cause"))
			return soap->error;
	}
	else
	if (soap_outliteral(soap, "ns2:cause", (char*const*)&a->cause, NULL))
		return soap->error;
	if (!a->message)
	{	if (soap_element_nil(soap, "ns2:message"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns2:message", -1, (char*const*)&a->message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__InvalidUsernamePasswordCombinationException * SOAP_FMAC4 soap_in__ns2__InvalidUsernamePasswordCombinationException(struct soap *soap, const char *tag, struct _ns2__InvalidUsernamePasswordCombinationException *a, const char *type)
{
	size_t soap_flag_cause = 1;
	size_t soap_flag_message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__InvalidUsernamePasswordCombinationException *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__InvalidUsernamePasswordCombinationException, sizeof(struct _ns2__InvalidUsernamePasswordCombinationException), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__InvalidUsernamePasswordCombinationException(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cause && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "ns2:cause", (char**)&a->cause))
				{	soap_flag_cause--;
					continue;
				}
			}
			if (soap_flag_message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns2:message", (char**)&a->message, "xsd:string"))
				{	soap_flag_message--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cause > 0 || soap_flag_message > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns2__InvalidUsernamePasswordCombinationException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__InvalidUsernamePasswordCombinationException, SOAP_TYPE__ns2__InvalidUsernamePasswordCombinationException, sizeof(struct _ns2__InvalidUsernamePasswordCombinationException), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns2__InvalidUsernamePasswordCombinationException * SOAP_FMAC4 soap_new__ns2__InvalidUsernamePasswordCombinationException(struct soap *soap, int n)
{
	struct _ns2__InvalidUsernamePasswordCombinationException *p;
	struct _ns2__InvalidUsernamePasswordCombinationException *a = (struct _ns2__InvalidUsernamePasswordCombinationException*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns2__InvalidUsernamePasswordCombinationException));
	for (p = a; p && n--; p++)
		soap_default__ns2__InvalidUsernamePasswordCombinationException(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__InvalidUsernamePasswordCombinationException(struct soap *soap, const struct _ns2__InvalidUsernamePasswordCombinationException *a, const char *tag, const char *type)
{
	if (soap_out__ns2__InvalidUsernamePasswordCombinationException(soap, tag ? tag : "ns2:InvalidUsernamePasswordCombinationException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__InvalidUsernamePasswordCombinationException * SOAP_FMAC4 soap_get__ns2__InvalidUsernamePasswordCombinationException(struct soap *soap, struct _ns2__InvalidUsernamePasswordCombinationException *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__InvalidUsernamePasswordCombinationException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__PermissionDeniedException(struct soap *soap, struct _ns2__PermissionDeniedException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cause = NULL;
	soap_default_string(soap, &a->message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__PermissionDeniedException(struct soap *soap, const struct _ns2__PermissionDeniedException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->message);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__PermissionDeniedException(struct soap *soap, const char *tag, int id, const struct _ns2__PermissionDeniedException *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__PermissionDeniedException), type))
		return soap->error;
	if (!a->cause)
	{	if (soap_element_nil(soap, "ns2:cause"))
			return soap->error;
	}
	else
	if (soap_outliteral(soap, "ns2:cause", (char*const*)&a->cause, NULL))
		return soap->error;
	if (!a->message)
	{	if (soap_element_nil(soap, "ns2:message"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns2:message", -1, (char*const*)&a->message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__PermissionDeniedException * SOAP_FMAC4 soap_in__ns2__PermissionDeniedException(struct soap *soap, const char *tag, struct _ns2__PermissionDeniedException *a, const char *type)
{
	size_t soap_flag_cause = 1;
	size_t soap_flag_message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__PermissionDeniedException *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__PermissionDeniedException, sizeof(struct _ns2__PermissionDeniedException), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__PermissionDeniedException(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cause && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "ns2:cause", (char**)&a->cause))
				{	soap_flag_cause--;
					continue;
				}
			}
			if (soap_flag_message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns2:message", (char**)&a->message, "xsd:string"))
				{	soap_flag_message--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cause > 0 || soap_flag_message > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns2__PermissionDeniedException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__PermissionDeniedException, SOAP_TYPE__ns2__PermissionDeniedException, sizeof(struct _ns2__PermissionDeniedException), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns2__PermissionDeniedException * SOAP_FMAC4 soap_new__ns2__PermissionDeniedException(struct soap *soap, int n)
{
	struct _ns2__PermissionDeniedException *p;
	struct _ns2__PermissionDeniedException *a = (struct _ns2__PermissionDeniedException*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns2__PermissionDeniedException));
	for (p = a; p && n--; p++)
		soap_default__ns2__PermissionDeniedException(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__PermissionDeniedException(struct soap *soap, const struct _ns2__PermissionDeniedException *a, const char *tag, const char *type)
{
	if (soap_out__ns2__PermissionDeniedException(soap, tag ? tag : "ns2:PermissionDeniedException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__PermissionDeniedException * SOAP_FMAC4 soap_get__ns2__PermissionDeniedException(struct soap *soap, struct _ns2__PermissionDeniedException *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__PermissionDeniedException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__InvalidClientException(struct soap *soap, struct _ns2__InvalidClientException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cause = NULL;
	soap_default_string(soap, &a->message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__InvalidClientException(struct soap *soap, const struct _ns2__InvalidClientException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->message);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__InvalidClientException(struct soap *soap, const char *tag, int id, const struct _ns2__InvalidClientException *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__InvalidClientException), type))
		return soap->error;
	if (!a->cause)
	{	if (soap_element_nil(soap, "ns2:cause"))
			return soap->error;
	}
	else
	if (soap_outliteral(soap, "ns2:cause", (char*const*)&a->cause, NULL))
		return soap->error;
	if (!a->message)
	{	if (soap_element_nil(soap, "ns2:message"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns2:message", -1, (char*const*)&a->message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__InvalidClientException * SOAP_FMAC4 soap_in__ns2__InvalidClientException(struct soap *soap, const char *tag, struct _ns2__InvalidClientException *a, const char *type)
{
	size_t soap_flag_cause = 1;
	size_t soap_flag_message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__InvalidClientException *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__InvalidClientException, sizeof(struct _ns2__InvalidClientException), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__InvalidClientException(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cause && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "ns2:cause", (char**)&a->cause))
				{	soap_flag_cause--;
					continue;
				}
			}
			if (soap_flag_message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns2:message", (char**)&a->message, "xsd:string"))
				{	soap_flag_message--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cause > 0 || soap_flag_message > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns2__InvalidClientException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__InvalidClientException, SOAP_TYPE__ns2__InvalidClientException, sizeof(struct _ns2__InvalidClientException), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns2__InvalidClientException * SOAP_FMAC4 soap_new__ns2__InvalidClientException(struct soap *soap, int n)
{
	struct _ns2__InvalidClientException *p;
	struct _ns2__InvalidClientException *a = (struct _ns2__InvalidClientException*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns2__InvalidClientException));
	for (p = a; p && n--; p++)
		soap_default__ns2__InvalidClientException(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__InvalidClientException(struct soap *soap, const struct _ns2__InvalidClientException *a, const char *tag, const char *type)
{
	if (soap_out__ns2__InvalidClientException(soap, tag ? tag : "ns2:InvalidClientException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__InvalidClientException * SOAP_FMAC4 soap_get__ns2__InvalidClientException(struct soap *soap, struct _ns2__InvalidClientException *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__InvalidClientException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__InvalidSessionException(struct soap *soap, struct _ns2__InvalidSessionException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cause = NULL;
	soap_default_string(soap, &a->message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__InvalidSessionException(struct soap *soap, const struct _ns2__InvalidSessionException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->message);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__InvalidSessionException(struct soap *soap, const char *tag, int id, const struct _ns2__InvalidSessionException *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__InvalidSessionException), type))
		return soap->error;
	if (!a->cause)
	{	if (soap_element_nil(soap, "ns2:cause"))
			return soap->error;
	}
	else
	if (soap_outliteral(soap, "ns2:cause", (char*const*)&a->cause, NULL))
		return soap->error;
	if (!a->message)
	{	if (soap_element_nil(soap, "ns2:message"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns2:message", -1, (char*const*)&a->message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__InvalidSessionException * SOAP_FMAC4 soap_in__ns2__InvalidSessionException(struct soap *soap, const char *tag, struct _ns2__InvalidSessionException *a, const char *type)
{
	size_t soap_flag_cause = 1;
	size_t soap_flag_message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__InvalidSessionException *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__InvalidSessionException, sizeof(struct _ns2__InvalidSessionException), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__InvalidSessionException(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cause && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "ns2:cause", (char**)&a->cause))
				{	soap_flag_cause--;
					continue;
				}
			}
			if (soap_flag_message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns2:message", (char**)&a->message, "xsd:string"))
				{	soap_flag_message--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cause > 0 || soap_flag_message > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns2__InvalidSessionException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__InvalidSessionException, SOAP_TYPE__ns2__InvalidSessionException, sizeof(struct _ns2__InvalidSessionException), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns2__InvalidSessionException * SOAP_FMAC4 soap_new__ns2__InvalidSessionException(struct soap *soap, int n)
{
	struct _ns2__InvalidSessionException *p;
	struct _ns2__InvalidSessionException *a = (struct _ns2__InvalidSessionException*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns2__InvalidSessionException));
	for (p = a; p && n--; p++)
		soap_default__ns2__InvalidSessionException(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__InvalidSessionException(struct soap *soap, const struct _ns2__InvalidSessionException *a, const char *tag, const char *type)
{
	if (soap_out__ns2__InvalidSessionException(soap, tag ? tag : "ns2:InvalidSessionException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__InvalidSessionException * SOAP_FMAC4 soap_get__ns2__InvalidSessionException(struct soap *soap, struct _ns2__InvalidSessionException *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__InvalidSessionException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__InvalidLicenseException(struct soap *soap, struct ns2__InvalidLicenseException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cause = NULL;
	soap_default_string(soap, &a->message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__InvalidLicenseException(struct soap *soap, const struct ns2__InvalidLicenseException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->message);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__InvalidLicenseException(struct soap *soap, const char *tag, int id, const struct ns2__InvalidLicenseException *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__InvalidLicenseException), type))
		return soap->error;
	if (!a->cause)
	{	if (soap_element_nil(soap, "ns2:cause"))
			return soap->error;
	}
	else
	if (soap_outliteral(soap, "ns2:cause", (char*const*)&a->cause, NULL))
		return soap->error;
	if (!a->message)
	{	if (soap_element_nil(soap, "ns2:message"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns2:message", -1, (char*const*)&a->message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__InvalidLicenseException * SOAP_FMAC4 soap_in_ns2__InvalidLicenseException(struct soap *soap, const char *tag, struct ns2__InvalidLicenseException *a, const char *type)
{
	size_t soap_flag_cause = 1;
	size_t soap_flag_message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__InvalidLicenseException *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__InvalidLicenseException, sizeof(struct ns2__InvalidLicenseException), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__InvalidLicenseException(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cause && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "ns2:cause", (char**)&a->cause))
				{	soap_flag_cause--;
					continue;
				}
			}
			if (soap_flag_message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns2:message", (char**)&a->message, "xsd:string"))
				{	soap_flag_message--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cause > 0 || soap_flag_message > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns2__InvalidLicenseException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__InvalidLicenseException, SOAP_TYPE_ns2__InvalidLicenseException, sizeof(struct ns2__InvalidLicenseException), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns2__InvalidLicenseException * SOAP_FMAC4 soap_new_ns2__InvalidLicenseException(struct soap *soap, int n)
{
	struct ns2__InvalidLicenseException *p;
	struct ns2__InvalidLicenseException *a = (struct ns2__InvalidLicenseException*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns2__InvalidLicenseException));
	for (p = a; p && n--; p++)
		soap_default_ns2__InvalidLicenseException(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__InvalidLicenseException(struct soap *soap, const struct ns2__InvalidLicenseException *a, const char *tag, const char *type)
{
	if (soap_out_ns2__InvalidLicenseException(soap, tag ? tag : "ns2:InvalidLicenseException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__InvalidLicenseException * SOAP_FMAC4 soap_get_ns2__InvalidLicenseException(struct soap *soap, struct ns2__InvalidLicenseException *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__InvalidLicenseException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__GeneralWebserviceException(struct soap *soap, struct _ns2__GeneralWebserviceException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cause = NULL;
	soap_default_string(soap, &a->message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__GeneralWebserviceException(struct soap *soap, const struct _ns2__GeneralWebserviceException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->message);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__GeneralWebserviceException(struct soap *soap, const char *tag, int id, const struct _ns2__GeneralWebserviceException *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__GeneralWebserviceException), type))
		return soap->error;
	if (!a->cause)
	{	if (soap_element_nil(soap, "ns2:cause"))
			return soap->error;
	}
	else
	if (soap_outliteral(soap, "ns2:cause", (char*const*)&a->cause, NULL))
		return soap->error;
	if (!a->message)
	{	if (soap_element_nil(soap, "ns2:message"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns2:message", -1, (char*const*)&a->message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__GeneralWebserviceException * SOAP_FMAC4 soap_in__ns2__GeneralWebserviceException(struct soap *soap, const char *tag, struct _ns2__GeneralWebserviceException *a, const char *type)
{
	size_t soap_flag_cause = 1;
	size_t soap_flag_message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__GeneralWebserviceException *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GeneralWebserviceException, sizeof(struct _ns2__GeneralWebserviceException), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__GeneralWebserviceException(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cause && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "ns2:cause", (char**)&a->cause))
				{	soap_flag_cause--;
					continue;
				}
			}
			if (soap_flag_message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns2:message", (char**)&a->message, "xsd:string"))
				{	soap_flag_message--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cause > 0 || soap_flag_message > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns2__GeneralWebserviceException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GeneralWebserviceException, SOAP_TYPE__ns2__GeneralWebserviceException, sizeof(struct _ns2__GeneralWebserviceException), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns2__GeneralWebserviceException * SOAP_FMAC4 soap_new__ns2__GeneralWebserviceException(struct soap *soap, int n)
{
	struct _ns2__GeneralWebserviceException *p;
	struct _ns2__GeneralWebserviceException *a = (struct _ns2__GeneralWebserviceException*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns2__GeneralWebserviceException));
	for (p = a; p && n--; p++)
		soap_default__ns2__GeneralWebserviceException(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__GeneralWebserviceException(struct soap *soap, const struct _ns2__GeneralWebserviceException *a, const char *tag, const char *type)
{
	if (soap_out__ns2__GeneralWebserviceException(soap, tag ? tag : "ns2:GeneralWebserviceException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__GeneralWebserviceException * SOAP_FMAC4 soap_get__ns2__GeneralWebserviceException(struct soap *soap, struct _ns2__GeneralWebserviceException *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__GeneralWebserviceException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__AssertionException(struct soap *soap, struct _ns2__AssertionException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cause = NULL;
	soap_default_string(soap, &a->message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__AssertionException(struct soap *soap, const struct _ns2__AssertionException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->message);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__AssertionException(struct soap *soap, const char *tag, int id, const struct _ns2__AssertionException *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__AssertionException), type))
		return soap->error;
	if (!a->cause)
	{	if (soap_element_nil(soap, "ns2:cause"))
			return soap->error;
	}
	else
	if (soap_outliteral(soap, "ns2:cause", (char*const*)&a->cause, NULL))
		return soap->error;
	if (!a->message)
	{	if (soap_element_nil(soap, "ns2:message"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns2:message", -1, (char*const*)&a->message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__AssertionException * SOAP_FMAC4 soap_in__ns2__AssertionException(struct soap *soap, const char *tag, struct _ns2__AssertionException *a, const char *type)
{
	size_t soap_flag_cause = 1;
	size_t soap_flag_message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__AssertionException *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__AssertionException, sizeof(struct _ns2__AssertionException), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__AssertionException(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cause && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "ns2:cause", (char**)&a->cause))
				{	soap_flag_cause--;
					continue;
				}
			}
			if (soap_flag_message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns2:message", (char**)&a->message, "xsd:string"))
				{	soap_flag_message--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cause > 0 || soap_flag_message > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns2__AssertionException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__AssertionException, SOAP_TYPE__ns2__AssertionException, sizeof(struct _ns2__AssertionException), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns2__AssertionException * SOAP_FMAC4 soap_new__ns2__AssertionException(struct soap *soap, int n)
{
	struct _ns2__AssertionException *p;
	struct _ns2__AssertionException *a = (struct _ns2__AssertionException*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns2__AssertionException));
	for (p = a; p && n--; p++)
		soap_default__ns2__AssertionException(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__AssertionException(struct soap *soap, const struct _ns2__AssertionException *a, const char *tag, const char *type)
{
	if (soap_out__ns2__AssertionException(soap, tag ? tag : "ns2:AssertionException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__AssertionException * SOAP_FMAC4 soap_get__ns2__AssertionException(struct soap *soap, struct _ns2__AssertionException *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__AssertionException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__InvalidParameterException(struct soap *soap, struct _ns2__InvalidParameterException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cause = NULL;
	soap_default_string(soap, &a->message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__InvalidParameterException(struct soap *soap, const struct _ns2__InvalidParameterException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->message);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__InvalidParameterException(struct soap *soap, const char *tag, int id, const struct _ns2__InvalidParameterException *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__InvalidParameterException), type))
		return soap->error;
	if (!a->cause)
	{	if (soap_element_nil(soap, "ns2:cause"))
			return soap->error;
	}
	else
	if (soap_outliteral(soap, "ns2:cause", (char*const*)&a->cause, NULL))
		return soap->error;
	if (!a->message)
	{	if (soap_element_nil(soap, "ns2:message"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns2:message", -1, (char*const*)&a->message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__InvalidParameterException * SOAP_FMAC4 soap_in__ns2__InvalidParameterException(struct soap *soap, const char *tag, struct _ns2__InvalidParameterException *a, const char *type)
{
	size_t soap_flag_cause = 1;
	size_t soap_flag_message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__InvalidParameterException *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__InvalidParameterException, sizeof(struct _ns2__InvalidParameterException), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__InvalidParameterException(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cause && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "ns2:cause", (char**)&a->cause))
				{	soap_flag_cause--;
					continue;
				}
			}
			if (soap_flag_message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns2:message", (char**)&a->message, "xsd:string"))
				{	soap_flag_message--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cause > 0 || soap_flag_message > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns2__InvalidParameterException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__InvalidParameterException, SOAP_TYPE__ns2__InvalidParameterException, sizeof(struct _ns2__InvalidParameterException), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns2__InvalidParameterException * SOAP_FMAC4 soap_new__ns2__InvalidParameterException(struct soap *soap, int n)
{
	struct _ns2__InvalidParameterException *p;
	struct _ns2__InvalidParameterException *a = (struct _ns2__InvalidParameterException*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns2__InvalidParameterException));
	for (p = a; p && n--; p++)
		soap_default__ns2__InvalidParameterException(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__InvalidParameterException(struct soap *soap, const struct _ns2__InvalidParameterException *a, const char *tag, const char *type)
{
	if (soap_out__ns2__InvalidParameterException(soap, tag ? tag : "ns2:InvalidParameterException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__InvalidParameterException * SOAP_FMAC4 soap_get__ns2__InvalidParameterException(struct soap *soap, struct _ns2__InvalidParameterException *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__InvalidParameterException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__WeekFinishedException(struct soap *soap, struct _ns2__WeekFinishedException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cause = NULL;
	soap_default_string(soap, &a->message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__WeekFinishedException(struct soap *soap, const struct _ns2__WeekFinishedException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->message);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__WeekFinishedException(struct soap *soap, const char *tag, int id, const struct _ns2__WeekFinishedException *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__WeekFinishedException), type))
		return soap->error;
	if (!a->cause)
	{	if (soap_element_nil(soap, "ns2:cause"))
			return soap->error;
	}
	else
	if (soap_outliteral(soap, "ns2:cause", (char*const*)&a->cause, NULL))
		return soap->error;
	if (!a->message)
	{	if (soap_element_nil(soap, "ns2:message"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns2:message", -1, (char*const*)&a->message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__WeekFinishedException * SOAP_FMAC4 soap_in__ns2__WeekFinishedException(struct soap *soap, const char *tag, struct _ns2__WeekFinishedException *a, const char *type)
{
	size_t soap_flag_cause = 1;
	size_t soap_flag_message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__WeekFinishedException *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__WeekFinishedException, sizeof(struct _ns2__WeekFinishedException), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__WeekFinishedException(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cause && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "ns2:cause", (char**)&a->cause))
				{	soap_flag_cause--;
					continue;
				}
			}
			if (soap_flag_message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns2:message", (char**)&a->message, "xsd:string"))
				{	soap_flag_message--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cause > 0 || soap_flag_message > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns2__WeekFinishedException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__WeekFinishedException, SOAP_TYPE__ns2__WeekFinishedException, sizeof(struct _ns2__WeekFinishedException), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns2__WeekFinishedException * SOAP_FMAC4 soap_new__ns2__WeekFinishedException(struct soap *soap, int n)
{
	struct _ns2__WeekFinishedException *p;
	struct _ns2__WeekFinishedException *a = (struct _ns2__WeekFinishedException*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns2__WeekFinishedException));
	for (p = a; p && n--; p++)
		soap_default__ns2__WeekFinishedException(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__WeekFinishedException(struct soap *soap, const struct _ns2__WeekFinishedException *a, const char *tag, const char *type)
{
	if (soap_out__ns2__WeekFinishedException(soap, tag ? tag : "ns2:WeekFinishedException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__WeekFinishedException * SOAP_FMAC4 soap_get__ns2__WeekFinishedException(struct soap *soap, struct _ns2__WeekFinishedException *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__WeekFinishedException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__UserManagementException(struct soap *soap, struct ns2__UserManagementException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cause = NULL;
	soap_default_string(soap, &a->message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__UserManagementException(struct soap *soap, const struct ns2__UserManagementException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->message);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__UserManagementException(struct soap *soap, const char *tag, int id, const struct ns2__UserManagementException *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__UserManagementException), type))
		return soap->error;
	if (!a->cause)
	{	if (soap_element_nil(soap, "ns2:cause"))
			return soap->error;
	}
	else
	if (soap_outliteral(soap, "ns2:cause", (char*const*)&a->cause, NULL))
		return soap->error;
	if (!a->message)
	{	if (soap_element_nil(soap, "ns2:message"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns2:message", -1, (char*const*)&a->message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__UserManagementException * SOAP_FMAC4 soap_in_ns2__UserManagementException(struct soap *soap, const char *tag, struct ns2__UserManagementException *a, const char *type)
{
	size_t soap_flag_cause = 1;
	size_t soap_flag_message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__UserManagementException *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__UserManagementException, sizeof(struct ns2__UserManagementException), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__UserManagementException(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cause && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "ns2:cause", (char**)&a->cause))
				{	soap_flag_cause--;
					continue;
				}
			}
			if (soap_flag_message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns2:message", (char**)&a->message, "xsd:string"))
				{	soap_flag_message--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cause > 0 || soap_flag_message > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns2__UserManagementException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__UserManagementException, SOAP_TYPE_ns2__UserManagementException, sizeof(struct ns2__UserManagementException), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns2__UserManagementException * SOAP_FMAC4 soap_new_ns2__UserManagementException(struct soap *soap, int n)
{
	struct ns2__UserManagementException *p;
	struct ns2__UserManagementException *a = (struct ns2__UserManagementException*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns2__UserManagementException));
	for (p = a; p && n--; p++)
		soap_default_ns2__UserManagementException(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__UserManagementException(struct soap *soap, const struct ns2__UserManagementException *a, const char *tag, const char *type)
{
	if (soap_out_ns2__UserManagementException(soap, tag ? tag : "ns2:UserManagementException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__UserManagementException * SOAP_FMAC4 soap_get_ns2__UserManagementException(struct soap *soap, struct ns2__UserManagementException *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__UserManagementException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__UserList(struct soap *soap, struct _ns3__UserList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeUser = 0;
	a->User_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__UserList(struct soap *soap, const struct _ns3__UserList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->User_)
	{	int i;
		for (i = 0; i < (int)a->__sizeUser; i++)
		{
			soap_embedded(soap, a->User_ + i, SOAP_TYPE_ns3__T_USCOREUser);
			soap_serialize_ns3__T_USCOREUser(soap, a->User_ + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__UserList(struct soap *soap, const char *tag, int id, const struct _ns3__UserList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__UserList), type))
		return soap->error;
	soap_element_result(soap, "-sizeUser");
	if (a->User_)
	{	int i;
		for (i = 0; i < (int)a->__sizeUser; i++)
			if (soap_out_ns3__T_USCOREUser(soap, "ns3:User", -1, a->User_ + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__UserList * SOAP_FMAC4 soap_in__ns3__UserList(struct soap *soap, const char *tag, struct _ns3__UserList *a, const char *type)
{
	struct soap_blist *soap_blist_User_ = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns3__UserList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__UserList, sizeof(struct _ns3__UserList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns3__UserList(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:User", 1, NULL))
			{	if (a->User_ == NULL)
				{	if (soap_blist_User_ == NULL)
						soap_blist_User_ = soap_alloc_block(soap);
					a->User_ = (struct ns3__T_USCOREUser *)soap_push_block_max(soap, soap_blist_User_, sizeof(struct ns3__T_USCOREUser));
					if (a->User_ == NULL)
						return NULL;
					soap_default_ns3__T_USCOREUser(soap, a->User_);
				}
				soap_revert(soap);
				if (soap_in_ns3__T_USCOREUser(soap, "ns3:User", a->User_, "ns3:T_User"))
				{	a->__sizeUser++;
					a->User_ = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeUser");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->User_)
			soap_pop_block(soap, soap_blist_User_);
		if (a->__sizeUser)
		{	a->User_ = (struct ns3__T_USCOREUser *)soap_save_block(soap, soap_blist_User_, NULL, 1);
		}
		else
		{	a->User_ = NULL;
			if (soap_blist_User_)
				soap_end_block(soap, soap_blist_User_);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns3__UserList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__UserList, SOAP_TYPE__ns3__UserList, sizeof(struct _ns3__UserList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns3__UserList * SOAP_FMAC4 soap_new__ns3__UserList(struct soap *soap, int n)
{
	struct _ns3__UserList *p;
	struct _ns3__UserList *a = (struct _ns3__UserList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns3__UserList));
	for (p = a; p && n--; p++)
		soap_default__ns3__UserList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__UserList(struct soap *soap, const struct _ns3__UserList *a, const char *tag, const char *type)
{
	if (soap_out__ns3__UserList(soap, tag ? tag : "ns3:UserList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__UserList * SOAP_FMAC4 soap_get__ns3__UserList(struct soap *soap, struct _ns3__UserList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__UserList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__deleteUserRequestParameter(struct soap *soap, struct _ns3__deleteUserRequestParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->sessionID);
	a->user = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__deleteUserRequestParameter(struct soap *soap, const struct _ns3__deleteUserRequestParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->sessionID);
	soap_serialize_PointerTons3__UserIDInfo(soap, &a->user);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__deleteUserRequestParameter(struct soap *soap, const char *tag, int id, const struct _ns3__deleteUserRequestParameter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__deleteUserRequestParameter), type))
		return soap->error;
	if (!a->sessionID)
	{	if (soap_element_empty(soap, "ns3:sessionID"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns3:sessionID", -1, (char*const*)&a->sessionID, ""))
		return soap->error;
	if (!a->user)
	{	if (soap_element_empty(soap, "ns3:user"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons3__UserIDInfo(soap, "ns3:user", -1, &a->user, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__deleteUserRequestParameter * SOAP_FMAC4 soap_in__ns3__deleteUserRequestParameter(struct soap *soap, const char *tag, struct _ns3__deleteUserRequestParameter *a, const char *type)
{
	size_t soap_flag_sessionID = 1;
	size_t soap_flag_user = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns3__deleteUserRequestParameter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__deleteUserRequestParameter, sizeof(struct _ns3__deleteUserRequestParameter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns3__deleteUserRequestParameter(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sessionID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns3:sessionID", (char**)&a->sessionID, "xsd:string"))
				{	soap_flag_sessionID--;
					continue;
				}
			}
			if (soap_flag_user && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__UserIDInfo(soap, "ns3:user", &a->user, "ns3:UserIDInfo"))
				{	soap_flag_user--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->sessionID || !a->user))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns3__deleteUserRequestParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__deleteUserRequestParameter, SOAP_TYPE__ns3__deleteUserRequestParameter, sizeof(struct _ns3__deleteUserRequestParameter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns3__deleteUserRequestParameter * SOAP_FMAC4 soap_new__ns3__deleteUserRequestParameter(struct soap *soap, int n)
{
	struct _ns3__deleteUserRequestParameter *p;
	struct _ns3__deleteUserRequestParameter *a = (struct _ns3__deleteUserRequestParameter*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns3__deleteUserRequestParameter));
	for (p = a; p && n--; p++)
		soap_default__ns3__deleteUserRequestParameter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__deleteUserRequestParameter(struct soap *soap, const struct _ns3__deleteUserRequestParameter *a, const char *tag, const char *type)
{
	if (soap_out__ns3__deleteUserRequestParameter(soap, tag ? tag : "ns3:deleteUserRequestParameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__deleteUserRequestParameter * SOAP_FMAC4 soap_get__ns3__deleteUserRequestParameter(struct soap *soap, struct _ns3__deleteUserRequestParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__deleteUserRequestParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__searchUserRequestParameter(struct soap *soap, struct _ns3__searchUserRequestParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->sessionID);
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->email);
	a->personID = NULL;
	a->permissionGroupID = NULL;
	soap_default_string(soap, &a->firstname);
	soap_default_string(soap, &a->lastname);
	soap_default_string(soap, &a->personalNumber);
	a->licenseType = NULL;
	a->userState = NULL;
	a->foreignKey = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__searchUserRequestParameter(struct soap *soap, const struct _ns3__searchUserRequestParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->sessionID);
	soap_serialize_string(soap, (char*const*)&a->username);
	soap_serialize_string(soap, (char*const*)&a->email);
	soap_serialize_PointerTons3__id(soap, &a->personID);
	soap_serialize_PointerTons3__id(soap, &a->permissionGroupID);
	soap_serialize_string(soap, (char*const*)&a->firstname);
	soap_serialize_string(soap, (char*const*)&a->lastname);
	soap_serialize_string(soap, (char*const*)&a->personalNumber);
	soap_serialize_PointerTons3__T_USCORELicenseType(soap, &a->licenseType);
	soap_serialize_PointerTons3__T_USCOREUserState(soap, &a->userState);
	soap_serialize_PointerTons3__T_USCOREForeignKey(soap, &a->foreignKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__searchUserRequestParameter(struct soap *soap, const char *tag, int id, const struct _ns3__searchUserRequestParameter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__searchUserRequestParameter), type))
		return soap->error;
	if (!a->sessionID)
	{	if (soap_element_empty(soap, "ns3:sessionID"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns3:sessionID", -1, (char*const*)&a->sessionID, ""))
		return soap->error;
	if (!a->username)
	{	if (soap_element_nil(soap, "ns3:username"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns3:username", -1, (char*const*)&a->username, ""))
		return soap->error;
	if (!a->email)
	{	if (soap_element_nil(soap, "ns3:email"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns3:email", -1, (char*const*)&a->email, ""))
		return soap->error;
	if (!a->personID)
	{	if (soap_element_nil(soap, "ns3:personID"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons3__id(soap, "ns3:personID", -1, &a->personID, ""))
		return soap->error;
	if (!a->permissionGroupID)
	{	if (soap_element_nil(soap, "ns3:permissionGroupID"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons3__id(soap, "ns3:permissionGroupID", -1, &a->permissionGroupID, ""))
		return soap->error;
	if (!a->firstname)
	{	if (soap_element_nil(soap, "ns3:firstname"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns3:firstname", -1, (char*const*)&a->firstname, ""))
		return soap->error;
	if (!a->lastname)
	{	if (soap_element_nil(soap, "ns3:lastname"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns3:lastname", -1, (char*const*)&a->lastname, ""))
		return soap->error;
	if (!a->personalNumber)
	{	if (soap_element_nil(soap, "ns3:personalNumber"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns3:personalNumber", -1, (char*const*)&a->personalNumber, ""))
		return soap->error;
	if (!a->licenseType)
	{	if (soap_element_nil(soap, "ns3:licenseType"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons3__T_USCORELicenseType(soap, "ns3:licenseType", -1, &a->licenseType, ""))
		return soap->error;
	if (!a->userState)
	{	if (soap_element_nil(soap, "ns3:userState"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons3__T_USCOREUserState(soap, "ns3:userState", -1, &a->userState, ""))
		return soap->error;
	if (!a->foreignKey)
	{	if (soap_element_nil(soap, "ns3:foreignKey"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons3__T_USCOREForeignKey(soap, "ns3:foreignKey", -1, &a->foreignKey, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__searchUserRequestParameter * SOAP_FMAC4 soap_in__ns3__searchUserRequestParameter(struct soap *soap, const char *tag, struct _ns3__searchUserRequestParameter *a, const char *type)
{
	size_t soap_flag_sessionID = 1;
	size_t soap_flag_username = 1;
	size_t soap_flag_email = 1;
	size_t soap_flag_personID = 1;
	size_t soap_flag_permissionGroupID = 1;
	size_t soap_flag_firstname = 1;
	size_t soap_flag_lastname = 1;
	size_t soap_flag_personalNumber = 1;
	size_t soap_flag_licenseType = 1;
	size_t soap_flag_userState = 1;
	size_t soap_flag_foreignKey = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns3__searchUserRequestParameter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__searchUserRequestParameter, sizeof(struct _ns3__searchUserRequestParameter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns3__searchUserRequestParameter(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sessionID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns3:sessionID", (char**)&a->sessionID, "xsd:string"))
				{	soap_flag_sessionID--;
					continue;
				}
			}
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns3:username", (char**)&a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			}
			if (soap_flag_email && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns3:email", (char**)&a->email, "xsd:string"))
				{	soap_flag_email--;
					continue;
				}
			}
			if (soap_flag_personID && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__id(soap, "ns3:personID", &a->personID, "ns3:id"))
				{	soap_flag_personID--;
					continue;
				}
			}
			if (soap_flag_permissionGroupID && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__id(soap, "ns3:permissionGroupID", &a->permissionGroupID, "ns3:id"))
				{	soap_flag_permissionGroupID--;
					continue;
				}
			}
			if (soap_flag_firstname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns3:firstname", (char**)&a->firstname, "xsd:string"))
				{	soap_flag_firstname--;
					continue;
				}
			}
			if (soap_flag_lastname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns3:lastname", (char**)&a->lastname, "xsd:string"))
				{	soap_flag_lastname--;
					continue;
				}
			}
			if (soap_flag_personalNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns3:personalNumber", (char**)&a->personalNumber, "xsd:string"))
				{	soap_flag_personalNumber--;
					continue;
				}
			}
			if (soap_flag_licenseType && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__T_USCORELicenseType(soap, "ns3:licenseType", &a->licenseType, "ns3:T_LicenseType"))
				{	soap_flag_licenseType--;
					continue;
				}
			}
			if (soap_flag_userState && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__T_USCOREUserState(soap, "ns3:userState", &a->userState, "ns3:T_UserState"))
				{	soap_flag_userState--;
					continue;
				}
			}
			if (soap_flag_foreignKey && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__T_USCOREForeignKey(soap, "ns3:foreignKey", &a->foreignKey, "ns3:T_ForeignKey"))
				{	soap_flag_foreignKey--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->sessionID || soap_flag_username > 0 || soap_flag_email > 0 || soap_flag_personID > 0 || soap_flag_permissionGroupID > 0 || soap_flag_firstname > 0 || soap_flag_lastname > 0 || soap_flag_personalNumber > 0 || soap_flag_licenseType > 0 || soap_flag_userState > 0 || soap_flag_foreignKey > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns3__searchUserRequestParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__searchUserRequestParameter, SOAP_TYPE__ns3__searchUserRequestParameter, sizeof(struct _ns3__searchUserRequestParameter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns3__searchUserRequestParameter * SOAP_FMAC4 soap_new__ns3__searchUserRequestParameter(struct soap *soap, int n)
{
	struct _ns3__searchUserRequestParameter *p;
	struct _ns3__searchUserRequestParameter *a = (struct _ns3__searchUserRequestParameter*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns3__searchUserRequestParameter));
	for (p = a; p && n--; p++)
		soap_default__ns3__searchUserRequestParameter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__searchUserRequestParameter(struct soap *soap, const struct _ns3__searchUserRequestParameter *a, const char *tag, const char *type)
{
	if (soap_out__ns3__searchUserRequestParameter(soap, tag ? tag : "ns3:searchUserRequestParameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__searchUserRequestParameter * SOAP_FMAC4 soap_get__ns3__searchUserRequestParameter(struct soap *soap, struct _ns3__searchUserRequestParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__searchUserRequestParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__createUserRequestParameter(struct soap *soap, struct _ns3__createUserRequestParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->sessionID);
	soap_default_ns3__id(soap, &a->personID);
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->passwort);
	a->permissionGroups = NULL;
	soap_default_xsd__date(soap, &a->accessFrom);
	soap_default_xsd__date(soap, &a->accessTo);
	a->licenseType = NULL;
	a->foreignKeyList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__createUserRequestParameter(struct soap *soap, const struct _ns3__createUserRequestParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->sessionID);
	soap_embedded(soap, &a->personID, SOAP_TYPE_ns3__id);
	soap_serialize_string(soap, (char*const*)&a->username);
	soap_serialize_string(soap, (char*const*)&a->passwort);
	soap_serialize_PointerTons3__T_USCOREIdList(soap, &a->permissionGroups);
	soap_serialize_xsd__date(soap, (char*const*)&a->accessFrom);
	soap_serialize_xsd__date(soap, (char*const*)&a->accessTo);
	soap_serialize_PointerTons3__T_USCORELicenseType(soap, &a->licenseType);
	soap_serialize_PointerTons3__T_USCOREForeignKeyList(soap, &a->foreignKeyList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__createUserRequestParameter(struct soap *soap, const char *tag, int id, const struct _ns3__createUserRequestParameter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__createUserRequestParameter), type))
		return soap->error;
	if (!a->sessionID)
	{	if (soap_element_empty(soap, "ns3:sessionID"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns3:sessionID", -1, (char*const*)&a->sessionID, ""))
		return soap->error;
	if (soap_out_ns3__id(soap, "ns3:personID", -1, &a->personID, ""))
		return soap->error;
	if (!a->username)
	{	if (soap_element_empty(soap, "ns3:username"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns3:username", -1, (char*const*)&a->username, ""))
		return soap->error;
	if (!a->passwort)
	{	if (soap_element_nil(soap, "ns3:passwort"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns3:passwort", -1, (char*const*)&a->passwort, ""))
		return soap->error;
	if (!a->permissionGroups)
	{	if (soap_element_nil(soap, "ns3:permissionGroups"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons3__T_USCOREIdList(soap, "ns3:permissionGroups", -1, &a->permissionGroups, ""))
		return soap->error;
	if (!a->accessFrom)
	{	if (soap_element_nil(soap, "ns3:accessFrom"))
			return soap->error;
	}
	else
	if (soap_out_xsd__date(soap, "ns3:accessFrom", -1, (char*const*)&a->accessFrom, ""))
		return soap->error;
	if (!a->accessTo)
	{	if (soap_element_nil(soap, "ns3:accessTo"))
			return soap->error;
	}
	else
	if (soap_out_xsd__date(soap, "ns3:accessTo", -1, (char*const*)&a->accessTo, ""))
		return soap->error;
	if (!a->licenseType)
	{	if (soap_element_nil(soap, "ns3:licenseType"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons3__T_USCORELicenseType(soap, "ns3:licenseType", -1, &a->licenseType, ""))
		return soap->error;
	if (!a->foreignKeyList)
	{	if (soap_element_nil(soap, "ns3:foreignKeyList"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons3__T_USCOREForeignKeyList(soap, "ns3:foreignKeyList", -1, &a->foreignKeyList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__createUserRequestParameter * SOAP_FMAC4 soap_in__ns3__createUserRequestParameter(struct soap *soap, const char *tag, struct _ns3__createUserRequestParameter *a, const char *type)
{
	size_t soap_flag_sessionID = 1;
	size_t soap_flag_personID = 1;
	size_t soap_flag_username = 1;
	size_t soap_flag_passwort = 1;
	size_t soap_flag_permissionGroups = 1;
	size_t soap_flag_accessFrom = 1;
	size_t soap_flag_accessTo = 1;
	size_t soap_flag_licenseType = 1;
	size_t soap_flag_foreignKeyList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns3__createUserRequestParameter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__createUserRequestParameter, sizeof(struct _ns3__createUserRequestParameter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns3__createUserRequestParameter(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sessionID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns3:sessionID", (char**)&a->sessionID, "xsd:string"))
				{	soap_flag_sessionID--;
					continue;
				}
			}
			if (soap_flag_personID && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns3__id(soap, "ns3:personID", &a->personID, "ns3:id"))
				{	soap_flag_personID--;
					continue;
				}
			}
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns3:username", (char**)&a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			}
			if (soap_flag_passwort && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns3:passwort", (char**)&a->passwort, "xsd:string"))
				{	soap_flag_passwort--;
					continue;
				}
			}
			if (soap_flag_permissionGroups && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__T_USCOREIdList(soap, "ns3:permissionGroups", &a->permissionGroups, "ns3:T_IdList"))
				{	soap_flag_permissionGroups--;
					continue;
				}
			}
			if (soap_flag_accessFrom && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__date(soap, "ns3:accessFrom", (char**)&a->accessFrom, "xsd:date"))
				{	soap_flag_accessFrom--;
					continue;
				}
			}
			if (soap_flag_accessTo && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__date(soap, "ns3:accessTo", (char**)&a->accessTo, "xsd:date"))
				{	soap_flag_accessTo--;
					continue;
				}
			}
			if (soap_flag_licenseType && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__T_USCORELicenseType(soap, "ns3:licenseType", &a->licenseType, "ns3:T_LicenseType"))
				{	soap_flag_licenseType--;
					continue;
				}
			}
			if (soap_flag_foreignKeyList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__T_USCOREForeignKeyList(soap, "ns3:foreignKeyList", &a->foreignKeyList, "ns3:T_ForeignKeyList"))
				{	soap_flag_foreignKeyList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->sessionID || soap_flag_personID > 0 || !a->username || soap_flag_passwort > 0 || soap_flag_permissionGroups > 0 || soap_flag_accessFrom > 0 || soap_flag_accessTo > 0 || soap_flag_licenseType > 0 || soap_flag_foreignKeyList > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns3__createUserRequestParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__createUserRequestParameter, SOAP_TYPE__ns3__createUserRequestParameter, sizeof(struct _ns3__createUserRequestParameter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns3__createUserRequestParameter * SOAP_FMAC4 soap_new__ns3__createUserRequestParameter(struct soap *soap, int n)
{
	struct _ns3__createUserRequestParameter *p;
	struct _ns3__createUserRequestParameter *a = (struct _ns3__createUserRequestParameter*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns3__createUserRequestParameter));
	for (p = a; p && n--; p++)
		soap_default__ns3__createUserRequestParameter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__createUserRequestParameter(struct soap *soap, const struct _ns3__createUserRequestParameter *a, const char *tag, const char *type)
{
	if (soap_out__ns3__createUserRequestParameter(soap, tag ? tag : "ns3:createUserRequestParameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__createUserRequestParameter * SOAP_FMAC4 soap_get__ns3__createUserRequestParameter(struct soap *soap, struct _ns3__createUserRequestParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__createUserRequestParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__LogoutRequestParameter(struct soap *soap, struct _ns3__LogoutRequestParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->sessionID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__LogoutRequestParameter(struct soap *soap, const struct _ns3__LogoutRequestParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->sessionID);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__LogoutRequestParameter(struct soap *soap, const char *tag, int id, const struct _ns3__LogoutRequestParameter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__LogoutRequestParameter), type))
		return soap->error;
	if (!a->sessionID)
	{	if (soap_element_empty(soap, "ns3:sessionID"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns3:sessionID", -1, (char*const*)&a->sessionID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__LogoutRequestParameter * SOAP_FMAC4 soap_in__ns3__LogoutRequestParameter(struct soap *soap, const char *tag, struct _ns3__LogoutRequestParameter *a, const char *type)
{
	size_t soap_flag_sessionID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns3__LogoutRequestParameter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__LogoutRequestParameter, sizeof(struct _ns3__LogoutRequestParameter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns3__LogoutRequestParameter(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sessionID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns3:sessionID", (char**)&a->sessionID, "xsd:string"))
				{	soap_flag_sessionID--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->sessionID))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns3__LogoutRequestParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__LogoutRequestParameter, SOAP_TYPE__ns3__LogoutRequestParameter, sizeof(struct _ns3__LogoutRequestParameter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns3__LogoutRequestParameter * SOAP_FMAC4 soap_new__ns3__LogoutRequestParameter(struct soap *soap, int n)
{
	struct _ns3__LogoutRequestParameter *p;
	struct _ns3__LogoutRequestParameter *a = (struct _ns3__LogoutRequestParameter*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns3__LogoutRequestParameter));
	for (p = a; p && n--; p++)
		soap_default__ns3__LogoutRequestParameter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__LogoutRequestParameter(struct soap *soap, const struct _ns3__LogoutRequestParameter *a, const char *tag, const char *type)
{
	if (soap_out__ns3__LogoutRequestParameter(soap, tag ? tag : "ns3:LogoutRequestParameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__LogoutRequestParameter * SOAP_FMAC4 soap_get__ns3__LogoutRequestParameter(struct soap *soap, struct _ns3__LogoutRequestParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__LogoutRequestParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__LoginImpersonateRequestParameter(struct soap *soap, struct _ns3__LoginImpersonateRequestParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	a->__union_LoginImpersonateRequestParameter = -1;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__LoginImpersonateRequestParameter(struct soap *soap, const struct _ns3__LoginImpersonateRequestParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->username);
	soap_serialize_string(soap, (char*const*)&a->password);
	soap_serialize__ns3__union_LoginImpersonateRequestParameter(soap, a->__union_LoginImpersonateRequestParameter, &a->union_LoginImpersonateRequestParameter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__LoginImpersonateRequestParameter(struct soap *soap, const char *tag, int id, const struct _ns3__LoginImpersonateRequestParameter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__LoginImpersonateRequestParameter), type))
		return soap->error;
	if (!a->username)
	{	if (soap_element_empty(soap, "ns3:username"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns3:username", -1, (char*const*)&a->username, ""))
		return soap->error;
	if (!a->password)
	{	if (soap_element_empty(soap, "ns3:password"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns3:password", -1, (char*const*)&a->password, ""))
		return soap->error;
	if (soap_out__ns3__union_LoginImpersonateRequestParameter(soap, a->__union_LoginImpersonateRequestParameter, &a->union_LoginImpersonateRequestParameter))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__LoginImpersonateRequestParameter * SOAP_FMAC4 soap_in__ns3__LoginImpersonateRequestParameter(struct soap *soap, const char *tag, struct _ns3__LoginImpersonateRequestParameter *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_union_LoginImpersonateRequestParameter = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns3__LoginImpersonateRequestParameter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__LoginImpersonateRequestParameter, sizeof(struct _ns3__LoginImpersonateRequestParameter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns3__LoginImpersonateRequestParameter(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns3:username", (char**)&a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns3:password", (char**)&a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			}
			if (soap_flag_union_LoginImpersonateRequestParameter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__ns3__union_LoginImpersonateRequestParameter(soap, &a->__union_LoginImpersonateRequestParameter, &a->union_LoginImpersonateRequestParameter))
				{	soap_flag_union_LoginImpersonateRequestParameter = 0;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->username || !a->password))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns3__LoginImpersonateRequestParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__LoginImpersonateRequestParameter, SOAP_TYPE__ns3__LoginImpersonateRequestParameter, sizeof(struct _ns3__LoginImpersonateRequestParameter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns3__LoginImpersonateRequestParameter * SOAP_FMAC4 soap_new__ns3__LoginImpersonateRequestParameter(struct soap *soap, int n)
{
	struct _ns3__LoginImpersonateRequestParameter *p;
	struct _ns3__LoginImpersonateRequestParameter *a = (struct _ns3__LoginImpersonateRequestParameter*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns3__LoginImpersonateRequestParameter));
	for (p = a; p && n--; p++)
		soap_default__ns3__LoginImpersonateRequestParameter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__LoginImpersonateRequestParameter(struct soap *soap, const struct _ns3__LoginImpersonateRequestParameter *a, const char *tag, const char *type)
{
	if (soap_out__ns3__LoginImpersonateRequestParameter(soap, tag ? tag : "ns3:LoginImpersonateRequestParameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__LoginImpersonateRequestParameter * SOAP_FMAC4 soap_get__ns3__LoginImpersonateRequestParameter(struct soap *soap, struct _ns3__LoginImpersonateRequestParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__LoginImpersonateRequestParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__LoginSAMLRequestParameter(struct soap *soap, struct _ns3__LoginSAMLRequestParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SAMLartifact);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__LoginSAMLRequestParameter(struct soap *soap, const struct _ns3__LoginSAMLRequestParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SAMLartifact);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__LoginSAMLRequestParameter(struct soap *soap, const char *tag, int id, const struct _ns3__LoginSAMLRequestParameter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__LoginSAMLRequestParameter), type))
		return soap->error;
	if (!a->SAMLartifact)
	{	if (soap_element_empty(soap, "ns3:SAMLartifact"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns3:SAMLartifact", -1, (char*const*)&a->SAMLartifact, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__LoginSAMLRequestParameter * SOAP_FMAC4 soap_in__ns3__LoginSAMLRequestParameter(struct soap *soap, const char *tag, struct _ns3__LoginSAMLRequestParameter *a, const char *type)
{
	size_t soap_flag_SAMLartifact = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns3__LoginSAMLRequestParameter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__LoginSAMLRequestParameter, sizeof(struct _ns3__LoginSAMLRequestParameter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns3__LoginSAMLRequestParameter(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SAMLartifact && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns3:SAMLartifact", (char**)&a->SAMLartifact, "xsd:string"))
				{	soap_flag_SAMLartifact--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->SAMLartifact))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns3__LoginSAMLRequestParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__LoginSAMLRequestParameter, SOAP_TYPE__ns3__LoginSAMLRequestParameter, sizeof(struct _ns3__LoginSAMLRequestParameter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns3__LoginSAMLRequestParameter * SOAP_FMAC4 soap_new__ns3__LoginSAMLRequestParameter(struct soap *soap, int n)
{
	struct _ns3__LoginSAMLRequestParameter *p;
	struct _ns3__LoginSAMLRequestParameter *a = (struct _ns3__LoginSAMLRequestParameter*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns3__LoginSAMLRequestParameter));
	for (p = a; p && n--; p++)
		soap_default__ns3__LoginSAMLRequestParameter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__LoginSAMLRequestParameter(struct soap *soap, const struct _ns3__LoginSAMLRequestParameter *a, const char *tag, const char *type)
{
	if (soap_out__ns3__LoginSAMLRequestParameter(soap, tag ? tag : "ns3:LoginSAMLRequestParameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__LoginSAMLRequestParameter * SOAP_FMAC4 soap_get__ns3__LoginSAMLRequestParameter(struct soap *soap, struct _ns3__LoginSAMLRequestParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__LoginSAMLRequestParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__LoginNoAuthRequestParameter(struct soap *soap, struct _ns3__LoginNoAuthRequestParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__LoginNoAuthRequestParameter(struct soap *soap, const struct _ns3__LoginNoAuthRequestParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->username);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__LoginNoAuthRequestParameter(struct soap *soap, const char *tag, int id, const struct _ns3__LoginNoAuthRequestParameter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__LoginNoAuthRequestParameter), type))
		return soap->error;
	if (!a->username)
	{	if (soap_element_empty(soap, "ns3:username"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns3:username", -1, (char*const*)&a->username, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__LoginNoAuthRequestParameter * SOAP_FMAC4 soap_in__ns3__LoginNoAuthRequestParameter(struct soap *soap, const char *tag, struct _ns3__LoginNoAuthRequestParameter *a, const char *type)
{
	size_t soap_flag_username = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns3__LoginNoAuthRequestParameter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__LoginNoAuthRequestParameter, sizeof(struct _ns3__LoginNoAuthRequestParameter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns3__LoginNoAuthRequestParameter(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns3:username", (char**)&a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->username))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns3__LoginNoAuthRequestParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__LoginNoAuthRequestParameter, SOAP_TYPE__ns3__LoginNoAuthRequestParameter, sizeof(struct _ns3__LoginNoAuthRequestParameter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns3__LoginNoAuthRequestParameter * SOAP_FMAC4 soap_new__ns3__LoginNoAuthRequestParameter(struct soap *soap, int n)
{
	struct _ns3__LoginNoAuthRequestParameter *p;
	struct _ns3__LoginNoAuthRequestParameter *a = (struct _ns3__LoginNoAuthRequestParameter*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns3__LoginNoAuthRequestParameter));
	for (p = a; p && n--; p++)
		soap_default__ns3__LoginNoAuthRequestParameter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__LoginNoAuthRequestParameter(struct soap *soap, const struct _ns3__LoginNoAuthRequestParameter *a, const char *tag, const char *type)
{
	if (soap_out__ns3__LoginNoAuthRequestParameter(soap, tag ? tag : "ns3:LoginNoAuthRequestParameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__LoginNoAuthRequestParameter * SOAP_FMAC4 soap_get__ns3__LoginNoAuthRequestParameter(struct soap *soap, struct _ns3__LoginNoAuthRequestParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__LoginNoAuthRequestParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__LoginRequestParameter(struct soap *soap, struct _ns3__LoginRequestParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__LoginRequestParameter(struct soap *soap, const struct _ns3__LoginRequestParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->username);
	soap_serialize_string(soap, (char*const*)&a->password);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__LoginRequestParameter(struct soap *soap, const char *tag, int id, const struct _ns3__LoginRequestParameter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__LoginRequestParameter), type))
		return soap->error;
	if (!a->username)
	{	if (soap_element_empty(soap, "ns3:username"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns3:username", -1, (char*const*)&a->username, ""))
		return soap->error;
	if (!a->password)
	{	if (soap_element_empty(soap, "ns3:password"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns3:password", -1, (char*const*)&a->password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__LoginRequestParameter * SOAP_FMAC4 soap_in__ns3__LoginRequestParameter(struct soap *soap, const char *tag, struct _ns3__LoginRequestParameter *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns3__LoginRequestParameter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__LoginRequestParameter, sizeof(struct _ns3__LoginRequestParameter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns3__LoginRequestParameter(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns3:username", (char**)&a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns3:password", (char**)&a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->username || !a->password))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns3__LoginRequestParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__LoginRequestParameter, SOAP_TYPE__ns3__LoginRequestParameter, sizeof(struct _ns3__LoginRequestParameter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns3__LoginRequestParameter * SOAP_FMAC4 soap_new__ns3__LoginRequestParameter(struct soap *soap, int n)
{
	struct _ns3__LoginRequestParameter *p;
	struct _ns3__LoginRequestParameter *a = (struct _ns3__LoginRequestParameter*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns3__LoginRequestParameter));
	for (p = a; p && n--; p++)
		soap_default__ns3__LoginRequestParameter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__LoginRequestParameter(struct soap *soap, const struct _ns3__LoginRequestParameter *a, const char *tag, const char *type)
{
	if (soap_out__ns3__LoginRequestParameter(soap, tag ? tag : "ns3:LoginRequestParameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__LoginRequestParameter * SOAP_FMAC4 soap_get__ns3__LoginRequestParameter(struct soap *soap, struct _ns3__LoginRequestParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__LoginRequestParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__session(struct soap *soap, struct _ns3__session *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->sessionID);
	soap_default_LONG64(soap, &a->personID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__session(struct soap *soap, const struct _ns3__session *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->sessionID);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__session(struct soap *soap, const char *tag, int id, const struct _ns3__session *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__session), type))
		return soap->error;
	if (a->sessionID)
		soap_element_result(soap, "ns3:sessionID");
	if (!a->sessionID)
	{	if (soap_element_empty(soap, "ns3:sessionID"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns3:sessionID", -1, (char*const*)&a->sessionID, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns3:personID", -1, &a->personID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__session * SOAP_FMAC4 soap_in__ns3__session(struct soap *soap, const char *tag, struct _ns3__session *a, const char *type)
{
	size_t soap_flag_sessionID = 1;
	size_t soap_flag_personID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns3__session *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__session, sizeof(struct _ns3__session), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns3__session(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sessionID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns3:sessionID", (char**)&a->sessionID, "xsd:string"))
				{	soap_flag_sessionID--;
					continue;
				}
			}
			if (soap_flag_personID && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "ns3:personID", &a->personID, "xsd:long"))
				{	soap_flag_personID--;
					continue;
				}
			}
			soap_check_result(soap, "ns3:sessionID");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->sessionID || soap_flag_personID > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns3__session *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__session, SOAP_TYPE__ns3__session, sizeof(struct _ns3__session), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns3__session * SOAP_FMAC4 soap_new__ns3__session(struct soap *soap, int n)
{
	struct _ns3__session *p;
	struct _ns3__session *a = (struct _ns3__session*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns3__session));
	for (p = a; p && n--; p++)
		soap_default__ns3__session(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__session(struct soap *soap, const struct _ns3__session *a, const char *tag, const char *type)
{
	if (soap_out__ns3__session(soap, tag ? tag : "ns3:session", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__session * SOAP_FMAC4 soap_get__ns3__session(struct soap *soap, struct _ns3__session *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__session(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__T_USCOREIdList(struct soap *soap, struct ns3__T_USCOREIdList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeID = 0;
	a->ID_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__T_USCOREIdList(struct soap *soap, const struct ns3__T_USCOREIdList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ID_)
	{	int i;
		for (i = 0; i < (int)a->__sizeID; i++)
		{
			soap_embedded(soap, a->ID_ + i, SOAP_TYPE_ns3__id);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__T_USCOREIdList(struct soap *soap, const char *tag, int id, const struct ns3__T_USCOREIdList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__T_USCOREIdList), type))
		return soap->error;
	if (a->ID_)
	{	int i;
		for (i = 0; i < (int)a->__sizeID; i++)
			if (soap_out_ns3__id(soap, "ns3:ID", -1, a->ID_ + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__T_USCOREIdList * SOAP_FMAC4 soap_in_ns3__T_USCOREIdList(struct soap *soap, const char *tag, struct ns3__T_USCOREIdList *a, const char *type)
{
	struct soap_blist *soap_blist_ID_ = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__T_USCOREIdList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__T_USCOREIdList, sizeof(struct ns3__T_USCOREIdList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__T_USCOREIdList(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:ID", 1, NULL))
			{	if (a->ID_ == NULL)
				{	if (soap_blist_ID_ == NULL)
						soap_blist_ID_ = soap_alloc_block(soap);
					a->ID_ = (LONG64 *)soap_push_block_max(soap, soap_blist_ID_, sizeof(LONG64));
					if (a->ID_ == NULL)
						return NULL;
					soap_default_ns3__id(soap, a->ID_);
				}
				soap_revert(soap);
				if (soap_in_ns3__id(soap, "ns3:ID", a->ID_, "ns3:id"))
				{	a->__sizeID++;
					a->ID_ = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ID_)
			soap_pop_block(soap, soap_blist_ID_);
		if (a->__sizeID)
		{	a->ID_ = (LONG64 *)soap_save_block(soap, soap_blist_ID_, NULL, 1);
		}
		else
		{	a->ID_ = NULL;
			if (soap_blist_ID_)
				soap_end_block(soap, soap_blist_ID_);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns3__T_USCOREIdList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__T_USCOREIdList, SOAP_TYPE_ns3__T_USCOREIdList, sizeof(struct ns3__T_USCOREIdList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns3__T_USCOREIdList * SOAP_FMAC4 soap_new_ns3__T_USCOREIdList(struct soap *soap, int n)
{
	struct ns3__T_USCOREIdList *p;
	struct ns3__T_USCOREIdList *a = (struct ns3__T_USCOREIdList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns3__T_USCOREIdList));
	for (p = a; p && n--; p++)
		soap_default_ns3__T_USCOREIdList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__T_USCOREIdList(struct soap *soap, const struct ns3__T_USCOREIdList *a, const char *tag, const char *type)
{
	if (soap_out_ns3__T_USCOREIdList(soap, tag ? tag : "ns3:T_IdList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__T_USCOREIdList * SOAP_FMAC4 soap_get_ns3__T_USCOREIdList(struct soap *soap, struct ns3__T_USCOREIdList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__T_USCOREIdList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__T_USCOREUser(struct soap *soap, struct ns3__T_USCOREUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns3__id(soap, &a->userID);
	soap_default_ns3__id(soap, &a->personID);
	soap_default_string(soap, &a->username);
	a->permissionGroups = NULL;
	soap_default_string(soap, &a->lastname);
	soap_default_string(soap, &a->firstname);
	soap_default_string(soap, &a->personalNumber);
	soap_default_string(soap, &a->email);
	soap_default_ns3__T_USCORELicenseType(soap, &a->licenseType);
	soap_default_ns3__T_USCOREUserState(soap, &a->userState);
	a->foreignKeyList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__T_USCOREUser(struct soap *soap, const struct ns3__T_USCOREUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->userID, SOAP_TYPE_ns3__id);
	soap_embedded(soap, &a->personID, SOAP_TYPE_ns3__id);
	soap_serialize_string(soap, (char*const*)&a->username);
	soap_serialize_PointerTons3__T_USCOREIdList(soap, &a->permissionGroups);
	soap_serialize_string(soap, (char*const*)&a->lastname);
	soap_serialize_string(soap, (char*const*)&a->firstname);
	soap_serialize_string(soap, (char*const*)&a->personalNumber);
	soap_serialize_string(soap, (char*const*)&a->email);
	soap_embedded(soap, &a->licenseType, SOAP_TYPE_ns3__T_USCORELicenseType);
	soap_embedded(soap, &a->userState, SOAP_TYPE_ns3__T_USCOREUserState);
	soap_serialize_PointerTons3__T_USCOREForeignKeyList(soap, &a->foreignKeyList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__T_USCOREUser(struct soap *soap, const char *tag, int id, const struct ns3__T_USCOREUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__T_USCOREUser), type))
		return soap->error;
	soap_element_result(soap, "ns3:userID");
	if (soap_out_ns3__id(soap, "ns3:userID", -1, &a->userID, ""))
		return soap->error;
	if (soap_out_ns3__id(soap, "ns3:personID", -1, &a->personID, ""))
		return soap->error;
	if (!a->username)
	{	if (soap_element_empty(soap, "ns3:username"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns3:username", -1, (char*const*)&a->username, ""))
		return soap->error;
	if (!a->permissionGroups)
	{	if (soap_element_empty(soap, "ns3:permissionGroups"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons3__T_USCOREIdList(soap, "ns3:permissionGroups", -1, &a->permissionGroups, ""))
		return soap->error;
	if (!a->lastname)
	{	if (soap_element_empty(soap, "ns3:lastname"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns3:lastname", -1, (char*const*)&a->lastname, ""))
		return soap->error;
	if (!a->firstname)
	{	if (soap_element_empty(soap, "ns3:firstname"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns3:firstname", -1, (char*const*)&a->firstname, ""))
		return soap->error;
	if (!a->personalNumber)
	{	if (soap_element_empty(soap, "ns3:personalNumber"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns3:personalNumber", -1, (char*const*)&a->personalNumber, ""))
		return soap->error;
	if (!a->email)
	{	if (soap_element_nil(soap, "ns3:email"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns3:email", -1, (char*const*)&a->email, ""))
		return soap->error;
	if (soap_out_ns3__T_USCORELicenseType(soap, "ns3:licenseType", -1, &a->licenseType, ""))
		return soap->error;
	if (soap_out_ns3__T_USCOREUserState(soap, "ns3:userState", -1, &a->userState, ""))
		return soap->error;
	if (!a->foreignKeyList)
	{	if (soap_element_nil(soap, "ns3:foreignKeyList"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons3__T_USCOREForeignKeyList(soap, "ns3:foreignKeyList", -1, &a->foreignKeyList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__T_USCOREUser * SOAP_FMAC4 soap_in_ns3__T_USCOREUser(struct soap *soap, const char *tag, struct ns3__T_USCOREUser *a, const char *type)
{
	size_t soap_flag_userID = 1;
	size_t soap_flag_personID = 1;
	size_t soap_flag_username = 1;
	size_t soap_flag_permissionGroups = 1;
	size_t soap_flag_lastname = 1;
	size_t soap_flag_firstname = 1;
	size_t soap_flag_personalNumber = 1;
	size_t soap_flag_email = 1;
	size_t soap_flag_licenseType = 1;
	size_t soap_flag_userState = 1;
	size_t soap_flag_foreignKeyList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__T_USCOREUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__T_USCOREUser, sizeof(struct ns3__T_USCOREUser), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__T_USCOREUser(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userID && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns3__id(soap, "ns3:userID", &a->userID, "ns3:id"))
				{	soap_flag_userID--;
					continue;
				}
			}
			if (soap_flag_personID && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns3__id(soap, "ns3:personID", &a->personID, "ns3:id"))
				{	soap_flag_personID--;
					continue;
				}
			}
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns3:username", (char**)&a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			}
			if (soap_flag_permissionGroups && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__T_USCOREIdList(soap, "ns3:permissionGroups", &a->permissionGroups, "ns3:T_IdList"))
				{	soap_flag_permissionGroups--;
					continue;
				}
			}
			if (soap_flag_lastname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns3:lastname", (char**)&a->lastname, "xsd:string"))
				{	soap_flag_lastname--;
					continue;
				}
			}
			if (soap_flag_firstname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns3:firstname", (char**)&a->firstname, "xsd:string"))
				{	soap_flag_firstname--;
					continue;
				}
			}
			if (soap_flag_personalNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns3:personalNumber", (char**)&a->personalNumber, "xsd:string"))
				{	soap_flag_personalNumber--;
					continue;
				}
			}
			if (soap_flag_email && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns3:email", (char**)&a->email, "xsd:string"))
				{	soap_flag_email--;
					continue;
				}
			}
			if (soap_flag_licenseType && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns3__T_USCORELicenseType(soap, "ns3:licenseType", &a->licenseType, "ns3:T_LicenseType"))
				{	soap_flag_licenseType--;
					continue;
				}
			}
			if (soap_flag_userState && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns3__T_USCOREUserState(soap, "ns3:userState", &a->userState, "ns3:T_UserState"))
				{	soap_flag_userState--;
					continue;
				}
			}
			if (soap_flag_foreignKeyList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__T_USCOREForeignKeyList(soap, "ns3:foreignKeyList", &a->foreignKeyList, "ns3:T_ForeignKeyList"))
				{	soap_flag_foreignKeyList--;
					continue;
				}
			}
			soap_check_result(soap, "ns3:userID");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_userID > 0 || soap_flag_personID > 0 || !a->username || !a->permissionGroups || !a->lastname || !a->firstname || !a->personalNumber || soap_flag_email > 0 || soap_flag_licenseType > 0 || soap_flag_userState > 0 || soap_flag_foreignKeyList > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns3__T_USCOREUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__T_USCOREUser, SOAP_TYPE_ns3__T_USCOREUser, sizeof(struct ns3__T_USCOREUser), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns3__T_USCOREUser * SOAP_FMAC4 soap_new_ns3__T_USCOREUser(struct soap *soap, int n)
{
	struct ns3__T_USCOREUser *p;
	struct ns3__T_USCOREUser *a = (struct ns3__T_USCOREUser*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns3__T_USCOREUser));
	for (p = a; p && n--; p++)
		soap_default_ns3__T_USCOREUser(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__T_USCOREUser(struct soap *soap, const struct ns3__T_USCOREUser *a, const char *tag, const char *type)
{
	if (soap_out_ns3__T_USCOREUser(soap, tag ? tag : "ns3:T_User", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__T_USCOREUser * SOAP_FMAC4 soap_get_ns3__T_USCOREUser(struct soap *soap, struct ns3__T_USCOREUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__T_USCOREUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__UserIDInfo(struct soap *soap, struct ns3__UserIDInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_UserIDInfo = -1;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__UserIDInfo(struct soap *soap, const struct ns3__UserIDInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns3__union_UserIDInfo(soap, a->__union_UserIDInfo, &a->union_UserIDInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__UserIDInfo(struct soap *soap, const char *tag, int id, const struct ns3__UserIDInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__UserIDInfo), type))
		return soap->error;
	if (soap_out__ns3__union_UserIDInfo(soap, a->__union_UserIDInfo, &a->union_UserIDInfo))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__UserIDInfo * SOAP_FMAC4 soap_in_ns3__UserIDInfo(struct soap *soap, const char *tag, struct ns3__UserIDInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__UserIDInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__UserIDInfo, sizeof(struct ns3__UserIDInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__UserIDInfo(soap, a);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__ns3__union_UserIDInfo(soap, &a->__union_UserIDInfo, &a->union_UserIDInfo))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (struct ns3__UserIDInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__UserIDInfo, SOAP_TYPE_ns3__UserIDInfo, sizeof(struct ns3__UserIDInfo), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns3__UserIDInfo * SOAP_FMAC4 soap_new_ns3__UserIDInfo(struct soap *soap, int n)
{
	struct ns3__UserIDInfo *p;
	struct ns3__UserIDInfo *a = (struct ns3__UserIDInfo*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns3__UserIDInfo));
	for (p = a; p && n--; p++)
		soap_default_ns3__UserIDInfo(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__UserIDInfo(struct soap *soap, const struct ns3__UserIDInfo *a, const char *tag, const char *type)
{
	if (soap_out_ns3__UserIDInfo(soap, tag ? tag : "ns3:UserIDInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__UserIDInfo * SOAP_FMAC4 soap_get_ns3__UserIDInfo(struct soap *soap, struct ns3__UserIDInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__UserIDInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__T_USCOREForeignKeyList(struct soap *soap, struct ns3__T_USCOREForeignKeyList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeForeignKey = 0;
	a->ForeignKey_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__T_USCOREForeignKeyList(struct soap *soap, const struct ns3__T_USCOREForeignKeyList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ForeignKey_)
	{	int i;
		for (i = 0; i < (int)a->__sizeForeignKey; i++)
		{
			soap_embedded(soap, a->ForeignKey_ + i, SOAP_TYPE_ns3__T_USCOREForeignKey);
			soap_serialize_ns3__T_USCOREForeignKey(soap, a->ForeignKey_ + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__T_USCOREForeignKeyList(struct soap *soap, const char *tag, int id, const struct ns3__T_USCOREForeignKeyList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__T_USCOREForeignKeyList), type))
		return soap->error;
	if (a->ForeignKey_)
	{	int i;
		for (i = 0; i < (int)a->__sizeForeignKey; i++)
			if (soap_out_ns3__T_USCOREForeignKey(soap, "ns3:ForeignKey", -1, a->ForeignKey_ + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__T_USCOREForeignKeyList * SOAP_FMAC4 soap_in_ns3__T_USCOREForeignKeyList(struct soap *soap, const char *tag, struct ns3__T_USCOREForeignKeyList *a, const char *type)
{
	struct soap_blist *soap_blist_ForeignKey_ = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__T_USCOREForeignKeyList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__T_USCOREForeignKeyList, sizeof(struct ns3__T_USCOREForeignKeyList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__T_USCOREForeignKeyList(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:ForeignKey", 1, NULL))
			{	if (a->ForeignKey_ == NULL)
				{	if (soap_blist_ForeignKey_ == NULL)
						soap_blist_ForeignKey_ = soap_alloc_block(soap);
					a->ForeignKey_ = (struct ns3__T_USCOREForeignKey *)soap_push_block_max(soap, soap_blist_ForeignKey_, sizeof(struct ns3__T_USCOREForeignKey));
					if (a->ForeignKey_ == NULL)
						return NULL;
					soap_default_ns3__T_USCOREForeignKey(soap, a->ForeignKey_);
				}
				soap_revert(soap);
				if (soap_in_ns3__T_USCOREForeignKey(soap, "ns3:ForeignKey", a->ForeignKey_, "ns3:T_ForeignKey"))
				{	a->__sizeForeignKey++;
					a->ForeignKey_ = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ForeignKey_)
			soap_pop_block(soap, soap_blist_ForeignKey_);
		if (a->__sizeForeignKey)
		{	a->ForeignKey_ = (struct ns3__T_USCOREForeignKey *)soap_save_block(soap, soap_blist_ForeignKey_, NULL, 1);
		}
		else
		{	a->ForeignKey_ = NULL;
			if (soap_blist_ForeignKey_)
				soap_end_block(soap, soap_blist_ForeignKey_);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns3__T_USCOREForeignKeyList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__T_USCOREForeignKeyList, SOAP_TYPE_ns3__T_USCOREForeignKeyList, sizeof(struct ns3__T_USCOREForeignKeyList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns3__T_USCOREForeignKeyList * SOAP_FMAC4 soap_new_ns3__T_USCOREForeignKeyList(struct soap *soap, int n)
{
	struct ns3__T_USCOREForeignKeyList *p;
	struct ns3__T_USCOREForeignKeyList *a = (struct ns3__T_USCOREForeignKeyList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns3__T_USCOREForeignKeyList));
	for (p = a; p && n--; p++)
		soap_default_ns3__T_USCOREForeignKeyList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__T_USCOREForeignKeyList(struct soap *soap, const struct ns3__T_USCOREForeignKeyList *a, const char *tag, const char *type)
{
	if (soap_out_ns3__T_USCOREForeignKeyList(soap, tag ? tag : "ns3:T_ForeignKeyList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__T_USCOREForeignKeyList * SOAP_FMAC4 soap_get_ns3__T_USCOREForeignKeyList(struct soap *soap, struct ns3__T_USCOREForeignKeyList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__T_USCOREForeignKeyList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__T_USCOREForeignKey(struct soap *soap, struct ns3__T_USCOREForeignKey *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->foreignID);
	soap_default_string(soap, &a->foreignSystem);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__T_USCOREForeignKey(struct soap *soap, const struct ns3__T_USCOREForeignKey *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->foreignID);
	soap_serialize_string(soap, (char*const*)&a->foreignSystem);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__T_USCOREForeignKey(struct soap *soap, const char *tag, int id, const struct ns3__T_USCOREForeignKey *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__T_USCOREForeignKey), type))
		return soap->error;
	if (!a->foreignID)
	{	if (soap_element_nil(soap, "ns3:foreignID"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns3:foreignID", -1, (char*const*)&a->foreignID, ""))
		return soap->error;
	if (!a->foreignSystem)
	{	if (soap_element_nil(soap, "ns3:foreignSystem"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns3:foreignSystem", -1, (char*const*)&a->foreignSystem, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__T_USCOREForeignKey * SOAP_FMAC4 soap_in_ns3__T_USCOREForeignKey(struct soap *soap, const char *tag, struct ns3__T_USCOREForeignKey *a, const char *type)
{
	size_t soap_flag_foreignID = 1;
	size_t soap_flag_foreignSystem = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__T_USCOREForeignKey *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__T_USCOREForeignKey, sizeof(struct ns3__T_USCOREForeignKey), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__T_USCOREForeignKey(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_foreignID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns3:foreignID", (char**)&a->foreignID, "xsd:string"))
				{	soap_flag_foreignID--;
					continue;
				}
			}
			if (soap_flag_foreignSystem && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns3:foreignSystem", (char**)&a->foreignSystem, "xsd:string"))
				{	soap_flag_foreignSystem--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_foreignID > 0 || soap_flag_foreignSystem > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns3__T_USCOREForeignKey *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__T_USCOREForeignKey, SOAP_TYPE_ns3__T_USCOREForeignKey, sizeof(struct ns3__T_USCOREForeignKey), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns3__T_USCOREForeignKey * SOAP_FMAC4 soap_new_ns3__T_USCOREForeignKey(struct soap *soap, int n)
{
	struct ns3__T_USCOREForeignKey *p;
	struct ns3__T_USCOREForeignKey *a = (struct ns3__T_USCOREForeignKey*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns3__T_USCOREForeignKey));
	for (p = a; p && n--; p++)
		soap_default_ns3__T_USCOREForeignKey(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__T_USCOREForeignKey(struct soap *soap, const struct ns3__T_USCOREForeignKey *a, const char *tag, const char *type)
{
	if (soap_out_ns3__T_USCOREForeignKey(soap, tag ? tag : "ns3:T_ForeignKey", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__T_USCOREForeignKey * SOAP_FMAC4 soap_get_ns3__T_USCOREForeignKey(struct soap *soap, struct ns3__T_USCOREForeignKey *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__T_USCOREForeignKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__GeneralWebserviceException(struct soap *soap, struct ns2__GeneralWebserviceException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cause = NULL;
	soap_default_string(soap, &a->message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__GeneralWebserviceException(struct soap *soap, const struct ns2__GeneralWebserviceException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->message);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__GeneralWebserviceException(struct soap *soap, const char *tag, int id, const struct ns2__GeneralWebserviceException *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__GeneralWebserviceException), type))
		return soap->error;
	if (!a->cause)
	{	if (soap_element_nil(soap, "ns2:cause"))
			return soap->error;
	}
	else
	if (soap_outliteral(soap, "ns2:cause", (char*const*)&a->cause, NULL))
		return soap->error;
	if (!a->message)
	{	if (soap_element_nil(soap, "ns2:message"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns2:message", -1, (char*const*)&a->message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__GeneralWebserviceException * SOAP_FMAC4 soap_in_ns2__GeneralWebserviceException(struct soap *soap, const char *tag, struct ns2__GeneralWebserviceException *a, const char *type)
{
	size_t soap_flag_cause = 1;
	size_t soap_flag_message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__GeneralWebserviceException *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__GeneralWebserviceException, sizeof(struct ns2__GeneralWebserviceException), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__GeneralWebserviceException(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cause && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "ns2:cause", (char**)&a->cause))
				{	soap_flag_cause--;
					continue;
				}
			}
			if (soap_flag_message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns2:message", (char**)&a->message, "xsd:string"))
				{	soap_flag_message--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cause > 0 || soap_flag_message > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns2__GeneralWebserviceException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__GeneralWebserviceException, SOAP_TYPE_ns2__GeneralWebserviceException, sizeof(struct ns2__GeneralWebserviceException), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns2__GeneralWebserviceException * SOAP_FMAC4 soap_new_ns2__GeneralWebserviceException(struct soap *soap, int n)
{
	struct ns2__GeneralWebserviceException *p;
	struct ns2__GeneralWebserviceException *a = (struct ns2__GeneralWebserviceException*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns2__GeneralWebserviceException));
	for (p = a; p && n--; p++)
		soap_default_ns2__GeneralWebserviceException(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__GeneralWebserviceException(struct soap *soap, const struct ns2__GeneralWebserviceException *a, const char *tag, const char *type)
{
	if (soap_out_ns2__GeneralWebserviceException(soap, tag ? tag : "ns2:GeneralWebserviceException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__GeneralWebserviceException * SOAP_FMAC4 soap_get_ns2__GeneralWebserviceException(struct soap *soap, struct ns2__GeneralWebserviceException *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__GeneralWebserviceException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__union_LoginImpersonateRequestParameter(struct soap *soap, int choice, const union _ns3__union_LoginImpersonateRequestParameter *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns3__union_LoginImpersonateRequestParameter_ImpersonateUsername:
		soap_serialize_string(soap, &a->ImpersonateUsername);
		break;
	case SOAP_UNION__ns3__union_LoginImpersonateRequestParameter_ImpersonateUserID:
		soap_serialize_PointerTons3__id(soap, &a->ImpersonateUserID);
		break;
	case SOAP_UNION__ns3__union_LoginImpersonateRequestParameter_ImpersonateForeignKey:
		soap_serialize_PointerTons3__T_USCOREForeignKey(soap, &a->ImpersonateForeignKey);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__union_LoginImpersonateRequestParameter(struct soap *soap, int choice, const union _ns3__union_LoginImpersonateRequestParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns3__union_LoginImpersonateRequestParameter_ImpersonateUsername:
		return soap_out_string(soap, "ns3:ImpersonateUsername", -1, (char*const*)&a->ImpersonateUsername, "");
	case SOAP_UNION__ns3__union_LoginImpersonateRequestParameter_ImpersonateUserID:
		return soap_out_PointerTons3__id(soap, "ns3:ImpersonateUserID", -1, &a->ImpersonateUserID, "");
	case SOAP_UNION__ns3__union_LoginImpersonateRequestParameter_ImpersonateForeignKey:
		return soap_out_PointerTons3__T_USCOREForeignKey(soap, "ns3:ImpersonateForeignKey", -1, &a->ImpersonateForeignKey, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns3__union_LoginImpersonateRequestParameter * SOAP_FMAC4 soap_in__ns3__union_LoginImpersonateRequestParameter(struct soap *soap, int *choice, union _ns3__union_LoginImpersonateRequestParameter *a)
{
	(void)a; /* appease -Wall -Werror */	soap->error = SOAP_TAG_MISMATCH;
	a->ImpersonateUsername = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_string(soap, "ns3:ImpersonateUsername", &a->ImpersonateUsername, "xsd:string"))
	{	*choice = SOAP_UNION__ns3__union_LoginImpersonateRequestParameter_ImpersonateUsername;
		return a;
	}
	a->ImpersonateUserID = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons3__id(soap, "ns3:ImpersonateUserID", &a->ImpersonateUserID, "ns3:id"))
	{	*choice = SOAP_UNION__ns3__union_LoginImpersonateRequestParameter_ImpersonateUserID;
		return a;
	}
	a->ImpersonateForeignKey = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons3__T_USCOREForeignKey(soap, "ns3:ImpersonateForeignKey", &a->ImpersonateForeignKey, "ns3:T_ForeignKey"))
	{	*choice = SOAP_UNION__ns3__union_LoginImpersonateRequestParameter_ImpersonateForeignKey;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__union_UserIDInfo(struct soap *soap, int choice, const union _ns3__union_UserIDInfo *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns3__union_UserIDInfo_userID:
		soap_embedded(soap, &a->userID, SOAP_TYPE_ns3__id);
		break;
	case SOAP_UNION__ns3__union_UserIDInfo_userName:
		soap_serialize_string(soap, &a->userName);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__union_UserIDInfo(struct soap *soap, int choice, const union _ns3__union_UserIDInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns3__union_UserIDInfo_userID:
		return soap_out_ns3__id(soap, "ns3:userID", -1, &a->userID, "");
	case SOAP_UNION__ns3__union_UserIDInfo_userName:
		return soap_out_string(soap, "ns3:userName", -1, (char*const*)&a->userName, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns3__union_UserIDInfo * SOAP_FMAC4 soap_in__ns3__union_UserIDInfo(struct soap *soap, int *choice, union _ns3__union_UserIDInfo *a)
{
	(void)a; /* appease -Wall -Werror */	soap->error = SOAP_TAG_MISMATCH;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_ns3__id(soap, "ns3:userID", &a->userID, "ns3:id"))
	{	*choice = SOAP_UNION__ns3__union_UserIDInfo_userID;
		return a;
	}
	a->userName = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_string(soap, "ns3:userName", &a->userName, "xsd:string"))
	{	*choice = SOAP_UNION__ns3__union_UserIDInfo_userName;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__UserList(struct soap *soap, struct _ns3__UserList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__UserList))
		soap_serialize__ns3__UserList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__UserList(struct soap *soap, const char *tag, int id, struct _ns3__UserList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__UserList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns3__UserList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns3__UserList ** SOAP_FMAC4 soap_in_PointerTo_ns3__UserList(struct soap *soap, const char *tag, struct _ns3__UserList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns3__UserList **)soap_malloc(soap, sizeof(struct _ns3__UserList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns3__UserList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns3__UserList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__UserList, sizeof(struct _ns3__UserList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__UserList(struct soap *soap, struct _ns3__UserList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__UserList(soap, tag ? tag : "ns3:UserList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__UserList ** SOAP_FMAC4 soap_get_PointerTo_ns3__UserList(struct soap *soap, struct _ns3__UserList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__UserList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__searchUserRequestParameter(struct soap *soap, struct _ns3__searchUserRequestParameter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__searchUserRequestParameter))
		soap_serialize__ns3__searchUserRequestParameter(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__searchUserRequestParameter(struct soap *soap, const char *tag, int id, struct _ns3__searchUserRequestParameter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__searchUserRequestParameter, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns3__searchUserRequestParameter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns3__searchUserRequestParameter ** SOAP_FMAC4 soap_in_PointerTo_ns3__searchUserRequestParameter(struct soap *soap, const char *tag, struct _ns3__searchUserRequestParameter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns3__searchUserRequestParameter **)soap_malloc(soap, sizeof(struct _ns3__searchUserRequestParameter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns3__searchUserRequestParameter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns3__searchUserRequestParameter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__searchUserRequestParameter, sizeof(struct _ns3__searchUserRequestParameter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__searchUserRequestParameter(struct soap *soap, struct _ns3__searchUserRequestParameter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__searchUserRequestParameter(soap, tag ? tag : "ns3:searchUserRequestParameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__searchUserRequestParameter ** SOAP_FMAC4 soap_get_PointerTo_ns3__searchUserRequestParameter(struct soap *soap, struct _ns3__searchUserRequestParameter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__searchUserRequestParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns1__deleteUserResponse(struct soap *soap, struct __ns1__deleteUserResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___ns1__deleteUserResponse))
		soap_serialize___ns1__deleteUserResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns1__deleteUserResponse(struct soap *soap, const char *tag, int id, struct __ns1__deleteUserResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns1__deleteUserResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___ns1__deleteUserResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __ns1__deleteUserResponse ** SOAP_FMAC4 soap_in_PointerTo__ns1__deleteUserResponse(struct soap *soap, const char *tag, struct __ns1__deleteUserResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __ns1__deleteUserResponse **)soap_malloc(soap, sizeof(struct __ns1__deleteUserResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___ns1__deleteUserResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __ns1__deleteUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns1__deleteUserResponse, sizeof(struct __ns1__deleteUserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns1__deleteUserResponse(struct soap *soap, struct __ns1__deleteUserResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__ns1__deleteUserResponse(soap, tag ? tag : "-ns1:deleteUserResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __ns1__deleteUserResponse ** SOAP_FMAC4 soap_get_PointerTo__ns1__deleteUserResponse(struct soap *soap, struct __ns1__deleteUserResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns1__deleteUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__deleteUserRequestParameter(struct soap *soap, struct _ns3__deleteUserRequestParameter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__deleteUserRequestParameter))
		soap_serialize__ns3__deleteUserRequestParameter(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__deleteUserRequestParameter(struct soap *soap, const char *tag, int id, struct _ns3__deleteUserRequestParameter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__deleteUserRequestParameter, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns3__deleteUserRequestParameter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns3__deleteUserRequestParameter ** SOAP_FMAC4 soap_in_PointerTo_ns3__deleteUserRequestParameter(struct soap *soap, const char *tag, struct _ns3__deleteUserRequestParameter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns3__deleteUserRequestParameter **)soap_malloc(soap, sizeof(struct _ns3__deleteUserRequestParameter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns3__deleteUserRequestParameter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns3__deleteUserRequestParameter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__deleteUserRequestParameter, sizeof(struct _ns3__deleteUserRequestParameter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__deleteUserRequestParameter(struct soap *soap, struct _ns3__deleteUserRequestParameter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__deleteUserRequestParameter(soap, tag ? tag : "ns3:deleteUserRequestParameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__deleteUserRequestParameter ** SOAP_FMAC4 soap_get_PointerTo_ns3__deleteUserRequestParameter(struct soap *soap, struct _ns3__deleteUserRequestParameter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__deleteUserRequestParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__createUserRequestParameter(struct soap *soap, struct _ns3__createUserRequestParameter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__createUserRequestParameter))
		soap_serialize__ns3__createUserRequestParameter(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__createUserRequestParameter(struct soap *soap, const char *tag, int id, struct _ns3__createUserRequestParameter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__createUserRequestParameter, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns3__createUserRequestParameter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns3__createUserRequestParameter ** SOAP_FMAC4 soap_in_PointerTo_ns3__createUserRequestParameter(struct soap *soap, const char *tag, struct _ns3__createUserRequestParameter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns3__createUserRequestParameter **)soap_malloc(soap, sizeof(struct _ns3__createUserRequestParameter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns3__createUserRequestParameter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns3__createUserRequestParameter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__createUserRequestParameter, sizeof(struct _ns3__createUserRequestParameter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__createUserRequestParameter(struct soap *soap, struct _ns3__createUserRequestParameter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__createUserRequestParameter(soap, tag ? tag : "ns3:createUserRequestParameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__createUserRequestParameter ** SOAP_FMAC4 soap_get_PointerTo_ns3__createUserRequestParameter(struct soap *soap, struct _ns3__createUserRequestParameter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__createUserRequestParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns1__LogoutResponse(struct soap *soap, struct __ns1__LogoutResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___ns1__LogoutResponse))
		soap_serialize___ns1__LogoutResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns1__LogoutResponse(struct soap *soap, const char *tag, int id, struct __ns1__LogoutResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns1__LogoutResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___ns1__LogoutResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __ns1__LogoutResponse ** SOAP_FMAC4 soap_in_PointerTo__ns1__LogoutResponse(struct soap *soap, const char *tag, struct __ns1__LogoutResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __ns1__LogoutResponse **)soap_malloc(soap, sizeof(struct __ns1__LogoutResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___ns1__LogoutResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __ns1__LogoutResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns1__LogoutResponse, sizeof(struct __ns1__LogoutResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns1__LogoutResponse(struct soap *soap, struct __ns1__LogoutResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__ns1__LogoutResponse(soap, tag ? tag : "-ns1:LogoutResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __ns1__LogoutResponse ** SOAP_FMAC4 soap_get_PointerTo__ns1__LogoutResponse(struct soap *soap, struct __ns1__LogoutResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns1__LogoutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__LogoutRequestParameter(struct soap *soap, struct _ns3__LogoutRequestParameter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__LogoutRequestParameter))
		soap_serialize__ns3__LogoutRequestParameter(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__LogoutRequestParameter(struct soap *soap, const char *tag, int id, struct _ns3__LogoutRequestParameter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__LogoutRequestParameter, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns3__LogoutRequestParameter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns3__LogoutRequestParameter ** SOAP_FMAC4 soap_in_PointerTo_ns3__LogoutRequestParameter(struct soap *soap, const char *tag, struct _ns3__LogoutRequestParameter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns3__LogoutRequestParameter **)soap_malloc(soap, sizeof(struct _ns3__LogoutRequestParameter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns3__LogoutRequestParameter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns3__LogoutRequestParameter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__LogoutRequestParameter, sizeof(struct _ns3__LogoutRequestParameter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__LogoutRequestParameter(struct soap *soap, struct _ns3__LogoutRequestParameter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__LogoutRequestParameter(soap, tag ? tag : "ns3:LogoutRequestParameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__LogoutRequestParameter ** SOAP_FMAC4 soap_get_PointerTo_ns3__LogoutRequestParameter(struct soap *soap, struct _ns3__LogoutRequestParameter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__LogoutRequestParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__LoginImpersonateRequestParameter(struct soap *soap, struct _ns3__LoginImpersonateRequestParameter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__LoginImpersonateRequestParameter))
		soap_serialize__ns3__LoginImpersonateRequestParameter(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__LoginImpersonateRequestParameter(struct soap *soap, const char *tag, int id, struct _ns3__LoginImpersonateRequestParameter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__LoginImpersonateRequestParameter, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns3__LoginImpersonateRequestParameter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns3__LoginImpersonateRequestParameter ** SOAP_FMAC4 soap_in_PointerTo_ns3__LoginImpersonateRequestParameter(struct soap *soap, const char *tag, struct _ns3__LoginImpersonateRequestParameter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns3__LoginImpersonateRequestParameter **)soap_malloc(soap, sizeof(struct _ns3__LoginImpersonateRequestParameter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns3__LoginImpersonateRequestParameter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns3__LoginImpersonateRequestParameter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__LoginImpersonateRequestParameter, sizeof(struct _ns3__LoginImpersonateRequestParameter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__LoginImpersonateRequestParameter(struct soap *soap, struct _ns3__LoginImpersonateRequestParameter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__LoginImpersonateRequestParameter(soap, tag ? tag : "ns3:LoginImpersonateRequestParameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__LoginImpersonateRequestParameter ** SOAP_FMAC4 soap_get_PointerTo_ns3__LoginImpersonateRequestParameter(struct soap *soap, struct _ns3__LoginImpersonateRequestParameter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__LoginImpersonateRequestParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__LoginSAMLRequestParameter(struct soap *soap, struct _ns3__LoginSAMLRequestParameter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__LoginSAMLRequestParameter))
		soap_serialize__ns3__LoginSAMLRequestParameter(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__LoginSAMLRequestParameter(struct soap *soap, const char *tag, int id, struct _ns3__LoginSAMLRequestParameter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__LoginSAMLRequestParameter, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns3__LoginSAMLRequestParameter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns3__LoginSAMLRequestParameter ** SOAP_FMAC4 soap_in_PointerTo_ns3__LoginSAMLRequestParameter(struct soap *soap, const char *tag, struct _ns3__LoginSAMLRequestParameter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns3__LoginSAMLRequestParameter **)soap_malloc(soap, sizeof(struct _ns3__LoginSAMLRequestParameter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns3__LoginSAMLRequestParameter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns3__LoginSAMLRequestParameter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__LoginSAMLRequestParameter, sizeof(struct _ns3__LoginSAMLRequestParameter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__LoginSAMLRequestParameter(struct soap *soap, struct _ns3__LoginSAMLRequestParameter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__LoginSAMLRequestParameter(soap, tag ? tag : "ns3:LoginSAMLRequestParameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__LoginSAMLRequestParameter ** SOAP_FMAC4 soap_get_PointerTo_ns3__LoginSAMLRequestParameter(struct soap *soap, struct _ns3__LoginSAMLRequestParameter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__LoginSAMLRequestParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__LoginNoAuthRequestParameter(struct soap *soap, struct _ns3__LoginNoAuthRequestParameter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__LoginNoAuthRequestParameter))
		soap_serialize__ns3__LoginNoAuthRequestParameter(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__LoginNoAuthRequestParameter(struct soap *soap, const char *tag, int id, struct _ns3__LoginNoAuthRequestParameter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__LoginNoAuthRequestParameter, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns3__LoginNoAuthRequestParameter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns3__LoginNoAuthRequestParameter ** SOAP_FMAC4 soap_in_PointerTo_ns3__LoginNoAuthRequestParameter(struct soap *soap, const char *tag, struct _ns3__LoginNoAuthRequestParameter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns3__LoginNoAuthRequestParameter **)soap_malloc(soap, sizeof(struct _ns3__LoginNoAuthRequestParameter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns3__LoginNoAuthRequestParameter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns3__LoginNoAuthRequestParameter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__LoginNoAuthRequestParameter, sizeof(struct _ns3__LoginNoAuthRequestParameter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__LoginNoAuthRequestParameter(struct soap *soap, struct _ns3__LoginNoAuthRequestParameter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__LoginNoAuthRequestParameter(soap, tag ? tag : "ns3:LoginNoAuthRequestParameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__LoginNoAuthRequestParameter ** SOAP_FMAC4 soap_get_PointerTo_ns3__LoginNoAuthRequestParameter(struct soap *soap, struct _ns3__LoginNoAuthRequestParameter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__LoginNoAuthRequestParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__session(struct soap *soap, struct _ns3__session *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__session))
		soap_serialize__ns3__session(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__session(struct soap *soap, const char *tag, int id, struct _ns3__session *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__session, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns3__session(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns3__session ** SOAP_FMAC4 soap_in_PointerTo_ns3__session(struct soap *soap, const char *tag, struct _ns3__session **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns3__session **)soap_malloc(soap, sizeof(struct _ns3__session *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns3__session(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns3__session **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__session, sizeof(struct _ns3__session), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__session(struct soap *soap, struct _ns3__session *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__session(soap, tag ? tag : "ns3:session", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__session ** SOAP_FMAC4 soap_get_PointerTo_ns3__session(struct soap *soap, struct _ns3__session **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__session(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__LoginRequestParameter(struct soap *soap, struct _ns3__LoginRequestParameter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__LoginRequestParameter))
		soap_serialize__ns3__LoginRequestParameter(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__LoginRequestParameter(struct soap *soap, const char *tag, int id, struct _ns3__LoginRequestParameter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__LoginRequestParameter, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns3__LoginRequestParameter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns3__LoginRequestParameter ** SOAP_FMAC4 soap_in_PointerTo_ns3__LoginRequestParameter(struct soap *soap, const char *tag, struct _ns3__LoginRequestParameter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns3__LoginRequestParameter **)soap_malloc(soap, sizeof(struct _ns3__LoginRequestParameter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns3__LoginRequestParameter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns3__LoginRequestParameter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__LoginRequestParameter, sizeof(struct _ns3__LoginRequestParameter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__LoginRequestParameter(struct soap *soap, struct _ns3__LoginRequestParameter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__LoginRequestParameter(soap, tag ? tag : "ns3:LoginRequestParameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__LoginRequestParameter ** SOAP_FMAC4 soap_get_PointerTo_ns3__LoginRequestParameter(struct soap *soap, struct _ns3__LoginRequestParameter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__LoginRequestParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__ServerMaintenanceException(struct soap *soap, struct _ns2__ServerMaintenanceException *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__ServerMaintenanceException))
		soap_serialize__ns2__ServerMaintenanceException(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__ServerMaintenanceException(struct soap *soap, const char *tag, int id, struct _ns2__ServerMaintenanceException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__ServerMaintenanceException, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__ServerMaintenanceException(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__ServerMaintenanceException ** SOAP_FMAC4 soap_in_PointerTo_ns2__ServerMaintenanceException(struct soap *soap, const char *tag, struct _ns2__ServerMaintenanceException **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__ServerMaintenanceException **)soap_malloc(soap, sizeof(struct _ns2__ServerMaintenanceException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__ServerMaintenanceException(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__ServerMaintenanceException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__ServerMaintenanceException, sizeof(struct _ns2__ServerMaintenanceException), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__ServerMaintenanceException(struct soap *soap, struct _ns2__ServerMaintenanceException *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns2__ServerMaintenanceException(soap, tag ? tag : "ns2:ServerMaintenanceException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__ServerMaintenanceException ** SOAP_FMAC4 soap_get_PointerTo_ns2__ServerMaintenanceException(struct soap *soap, struct _ns2__ServerMaintenanceException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__ServerMaintenanceException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__PermissionDeniedException(struct soap *soap, struct _ns2__PermissionDeniedException *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__PermissionDeniedException))
		soap_serialize__ns2__PermissionDeniedException(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__PermissionDeniedException(struct soap *soap, const char *tag, int id, struct _ns2__PermissionDeniedException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__PermissionDeniedException, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__PermissionDeniedException(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__PermissionDeniedException ** SOAP_FMAC4 soap_in_PointerTo_ns2__PermissionDeniedException(struct soap *soap, const char *tag, struct _ns2__PermissionDeniedException **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__PermissionDeniedException **)soap_malloc(soap, sizeof(struct _ns2__PermissionDeniedException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__PermissionDeniedException(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__PermissionDeniedException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__PermissionDeniedException, sizeof(struct _ns2__PermissionDeniedException), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__PermissionDeniedException(struct soap *soap, struct _ns2__PermissionDeniedException *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns2__PermissionDeniedException(soap, tag ? tag : "ns2:PermissionDeniedException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__PermissionDeniedException ** SOAP_FMAC4 soap_get_PointerTo_ns2__PermissionDeniedException(struct soap *soap, struct _ns2__PermissionDeniedException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__PermissionDeniedException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__InvalidUsernamePasswordCombinationException(struct soap *soap, struct _ns2__InvalidUsernamePasswordCombinationException *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__InvalidUsernamePasswordCombinationException))
		soap_serialize__ns2__InvalidUsernamePasswordCombinationException(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__InvalidUsernamePasswordCombinationException(struct soap *soap, const char *tag, int id, struct _ns2__InvalidUsernamePasswordCombinationException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__InvalidUsernamePasswordCombinationException, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__InvalidUsernamePasswordCombinationException(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__InvalidUsernamePasswordCombinationException ** SOAP_FMAC4 soap_in_PointerTo_ns2__InvalidUsernamePasswordCombinationException(struct soap *soap, const char *tag, struct _ns2__InvalidUsernamePasswordCombinationException **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__InvalidUsernamePasswordCombinationException **)soap_malloc(soap, sizeof(struct _ns2__InvalidUsernamePasswordCombinationException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__InvalidUsernamePasswordCombinationException(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__InvalidUsernamePasswordCombinationException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__InvalidUsernamePasswordCombinationException, sizeof(struct _ns2__InvalidUsernamePasswordCombinationException), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__InvalidUsernamePasswordCombinationException(struct soap *soap, struct _ns2__InvalidUsernamePasswordCombinationException *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns2__InvalidUsernamePasswordCombinationException(soap, tag ? tag : "ns2:InvalidUsernamePasswordCombinationException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__InvalidUsernamePasswordCombinationException ** SOAP_FMAC4 soap_get_PointerTo_ns2__InvalidUsernamePasswordCombinationException(struct soap *soap, struct _ns2__InvalidUsernamePasswordCombinationException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__InvalidUsernamePasswordCombinationException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__InvalidUsernameException(struct soap *soap, struct _ns2__InvalidUsernameException *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__InvalidUsernameException))
		soap_serialize__ns2__InvalidUsernameException(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__InvalidUsernameException(struct soap *soap, const char *tag, int id, struct _ns2__InvalidUsernameException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__InvalidUsernameException, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__InvalidUsernameException(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__InvalidUsernameException ** SOAP_FMAC4 soap_in_PointerTo_ns2__InvalidUsernameException(struct soap *soap, const char *tag, struct _ns2__InvalidUsernameException **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__InvalidUsernameException **)soap_malloc(soap, sizeof(struct _ns2__InvalidUsernameException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__InvalidUsernameException(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__InvalidUsernameException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__InvalidUsernameException, sizeof(struct _ns2__InvalidUsernameException), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__InvalidUsernameException(struct soap *soap, struct _ns2__InvalidUsernameException *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns2__InvalidUsernameException(soap, tag ? tag : "ns2:InvalidUsernameException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__InvalidUsernameException ** SOAP_FMAC4 soap_get_PointerTo_ns2__InvalidUsernameException(struct soap *soap, struct _ns2__InvalidUsernameException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__InvalidUsernameException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__InvalidSessionException(struct soap *soap, struct _ns2__InvalidSessionException *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__InvalidSessionException))
		soap_serialize__ns2__InvalidSessionException(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__InvalidSessionException(struct soap *soap, const char *tag, int id, struct _ns2__InvalidSessionException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__InvalidSessionException, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__InvalidSessionException(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__InvalidSessionException ** SOAP_FMAC4 soap_in_PointerTo_ns2__InvalidSessionException(struct soap *soap, const char *tag, struct _ns2__InvalidSessionException **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__InvalidSessionException **)soap_malloc(soap, sizeof(struct _ns2__InvalidSessionException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__InvalidSessionException(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__InvalidSessionException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__InvalidSessionException, sizeof(struct _ns2__InvalidSessionException), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__InvalidSessionException(struct soap *soap, struct _ns2__InvalidSessionException *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns2__InvalidSessionException(soap, tag ? tag : "ns2:InvalidSessionException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__InvalidSessionException ** SOAP_FMAC4 soap_get_PointerTo_ns2__InvalidSessionException(struct soap *soap, struct _ns2__InvalidSessionException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__InvalidSessionException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__InvalidParameterException(struct soap *soap, struct _ns2__InvalidParameterException *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__InvalidParameterException))
		soap_serialize__ns2__InvalidParameterException(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__InvalidParameterException(struct soap *soap, const char *tag, int id, struct _ns2__InvalidParameterException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__InvalidParameterException, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__InvalidParameterException(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__InvalidParameterException ** SOAP_FMAC4 soap_in_PointerTo_ns2__InvalidParameterException(struct soap *soap, const char *tag, struct _ns2__InvalidParameterException **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__InvalidParameterException **)soap_malloc(soap, sizeof(struct _ns2__InvalidParameterException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__InvalidParameterException(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__InvalidParameterException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__InvalidParameterException, sizeof(struct _ns2__InvalidParameterException), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__InvalidParameterException(struct soap *soap, struct _ns2__InvalidParameterException *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns2__InvalidParameterException(soap, tag ? tag : "ns2:InvalidParameterException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__InvalidParameterException ** SOAP_FMAC4 soap_get_PointerTo_ns2__InvalidParameterException(struct soap *soap, struct _ns2__InvalidParameterException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__InvalidParameterException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__InvalidNrOfImpersonationsException(struct soap *soap, struct _ns2__InvalidNrOfImpersonationsException *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__InvalidNrOfImpersonationsException))
		soap_serialize__ns2__InvalidNrOfImpersonationsException(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__InvalidNrOfImpersonationsException(struct soap *soap, const char *tag, int id, struct _ns2__InvalidNrOfImpersonationsException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__InvalidNrOfImpersonationsException, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__InvalidNrOfImpersonationsException(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__InvalidNrOfImpersonationsException ** SOAP_FMAC4 soap_in_PointerTo_ns2__InvalidNrOfImpersonationsException(struct soap *soap, const char *tag, struct _ns2__InvalidNrOfImpersonationsException **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__InvalidNrOfImpersonationsException **)soap_malloc(soap, sizeof(struct _ns2__InvalidNrOfImpersonationsException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__InvalidNrOfImpersonationsException(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__InvalidNrOfImpersonationsException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__InvalidNrOfImpersonationsException, sizeof(struct _ns2__InvalidNrOfImpersonationsException), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__InvalidNrOfImpersonationsException(struct soap *soap, struct _ns2__InvalidNrOfImpersonationsException *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns2__InvalidNrOfImpersonationsException(soap, tag ? tag : "ns2:InvalidNrOfImpersonationsException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__InvalidNrOfImpersonationsException ** SOAP_FMAC4 soap_get_PointerTo_ns2__InvalidNrOfImpersonationsException(struct soap *soap, struct _ns2__InvalidNrOfImpersonationsException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__InvalidNrOfImpersonationsException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__InvalidNamedLicenseException(struct soap *soap, struct _ns2__InvalidNamedLicenseException *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__InvalidNamedLicenseException))
		soap_serialize__ns2__InvalidNamedLicenseException(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__InvalidNamedLicenseException(struct soap *soap, const char *tag, int id, struct _ns2__InvalidNamedLicenseException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__InvalidNamedLicenseException, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__InvalidNamedLicenseException(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__InvalidNamedLicenseException ** SOAP_FMAC4 soap_in_PointerTo_ns2__InvalidNamedLicenseException(struct soap *soap, const char *tag, struct _ns2__InvalidNamedLicenseException **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__InvalidNamedLicenseException **)soap_malloc(soap, sizeof(struct _ns2__InvalidNamedLicenseException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__InvalidNamedLicenseException(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__InvalidNamedLicenseException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__InvalidNamedLicenseException, sizeof(struct _ns2__InvalidNamedLicenseException), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__InvalidNamedLicenseException(struct soap *soap, struct _ns2__InvalidNamedLicenseException *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns2__InvalidNamedLicenseException(soap, tag ? tag : "ns2:InvalidNamedLicenseException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__InvalidNamedLicenseException ** SOAP_FMAC4 soap_get_PointerTo_ns2__InvalidNamedLicenseException(struct soap *soap, struct _ns2__InvalidNamedLicenseException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__InvalidNamedLicenseException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__InvalidDatesException(struct soap *soap, struct _ns2__InvalidDatesException *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__InvalidDatesException))
		soap_serialize__ns2__InvalidDatesException(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__InvalidDatesException(struct soap *soap, const char *tag, int id, struct _ns2__InvalidDatesException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__InvalidDatesException, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__InvalidDatesException(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__InvalidDatesException ** SOAP_FMAC4 soap_in_PointerTo_ns2__InvalidDatesException(struct soap *soap, const char *tag, struct _ns2__InvalidDatesException **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__InvalidDatesException **)soap_malloc(soap, sizeof(struct _ns2__InvalidDatesException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__InvalidDatesException(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__InvalidDatesException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__InvalidDatesException, sizeof(struct _ns2__InvalidDatesException), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__InvalidDatesException(struct soap *soap, struct _ns2__InvalidDatesException *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns2__InvalidDatesException(soap, tag ? tag : "ns2:InvalidDatesException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__InvalidDatesException ** SOAP_FMAC4 soap_get_PointerTo_ns2__InvalidDatesException(struct soap *soap, struct _ns2__InvalidDatesException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__InvalidDatesException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__InvalidConcurrentLicenseException(struct soap *soap, struct _ns2__InvalidConcurrentLicenseException *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__InvalidConcurrentLicenseException))
		soap_serialize__ns2__InvalidConcurrentLicenseException(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__InvalidConcurrentLicenseException(struct soap *soap, const char *tag, int id, struct _ns2__InvalidConcurrentLicenseException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__InvalidConcurrentLicenseException, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__InvalidConcurrentLicenseException(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__InvalidConcurrentLicenseException ** SOAP_FMAC4 soap_in_PointerTo_ns2__InvalidConcurrentLicenseException(struct soap *soap, const char *tag, struct _ns2__InvalidConcurrentLicenseException **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__InvalidConcurrentLicenseException **)soap_malloc(soap, sizeof(struct _ns2__InvalidConcurrentLicenseException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__InvalidConcurrentLicenseException(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__InvalidConcurrentLicenseException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__InvalidConcurrentLicenseException, sizeof(struct _ns2__InvalidConcurrentLicenseException), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__InvalidConcurrentLicenseException(struct soap *soap, struct _ns2__InvalidConcurrentLicenseException *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns2__InvalidConcurrentLicenseException(soap, tag ? tag : "ns2:InvalidConcurrentLicenseException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__InvalidConcurrentLicenseException ** SOAP_FMAC4 soap_get_PointerTo_ns2__InvalidConcurrentLicenseException(struct soap *soap, struct _ns2__InvalidConcurrentLicenseException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__InvalidConcurrentLicenseException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__InvalidClientException(struct soap *soap, struct _ns2__InvalidClientException *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__InvalidClientException))
		soap_serialize__ns2__InvalidClientException(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__InvalidClientException(struct soap *soap, const char *tag, int id, struct _ns2__InvalidClientException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__InvalidClientException, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__InvalidClientException(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__InvalidClientException ** SOAP_FMAC4 soap_in_PointerTo_ns2__InvalidClientException(struct soap *soap, const char *tag, struct _ns2__InvalidClientException **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__InvalidClientException **)soap_malloc(soap, sizeof(struct _ns2__InvalidClientException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__InvalidClientException(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__InvalidClientException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__InvalidClientException, sizeof(struct _ns2__InvalidClientException), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__InvalidClientException(struct soap *soap, struct _ns2__InvalidClientException *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns2__InvalidClientException(soap, tag ? tag : "ns2:InvalidClientException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__InvalidClientException ** SOAP_FMAC4 soap_get_PointerTo_ns2__InvalidClientException(struct soap *soap, struct _ns2__InvalidClientException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__InvalidClientException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__ImpersonatedUserNotFoundException(struct soap *soap, struct _ns2__ImpersonatedUserNotFoundException *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__ImpersonatedUserNotFoundException))
		soap_serialize__ns2__ImpersonatedUserNotFoundException(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__ImpersonatedUserNotFoundException(struct soap *soap, const char *tag, int id, struct _ns2__ImpersonatedUserNotFoundException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__ImpersonatedUserNotFoundException, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__ImpersonatedUserNotFoundException(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__ImpersonatedUserNotFoundException ** SOAP_FMAC4 soap_in_PointerTo_ns2__ImpersonatedUserNotFoundException(struct soap *soap, const char *tag, struct _ns2__ImpersonatedUserNotFoundException **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__ImpersonatedUserNotFoundException **)soap_malloc(soap, sizeof(struct _ns2__ImpersonatedUserNotFoundException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__ImpersonatedUserNotFoundException(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__ImpersonatedUserNotFoundException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__ImpersonatedUserNotFoundException, sizeof(struct _ns2__ImpersonatedUserNotFoundException), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__ImpersonatedUserNotFoundException(struct soap *soap, struct _ns2__ImpersonatedUserNotFoundException *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns2__ImpersonatedUserNotFoundException(soap, tag ? tag : "ns2:ImpersonatedUserNotFoundException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__ImpersonatedUserNotFoundException ** SOAP_FMAC4 soap_get_PointerTo_ns2__ImpersonatedUserNotFoundException(struct soap *soap, struct _ns2__ImpersonatedUserNotFoundException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__ImpersonatedUserNotFoundException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__GeneralWebserviceException(struct soap *soap, struct _ns2__GeneralWebserviceException *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__GeneralWebserviceException))
		soap_serialize__ns2__GeneralWebserviceException(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__GeneralWebserviceException(struct soap *soap, const char *tag, int id, struct _ns2__GeneralWebserviceException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__GeneralWebserviceException, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__GeneralWebserviceException(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__GeneralWebserviceException ** SOAP_FMAC4 soap_in_PointerTo_ns2__GeneralWebserviceException(struct soap *soap, const char *tag, struct _ns2__GeneralWebserviceException **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__GeneralWebserviceException **)soap_malloc(soap, sizeof(struct _ns2__GeneralWebserviceException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__GeneralWebserviceException(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__GeneralWebserviceException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__GeneralWebserviceException, sizeof(struct _ns2__GeneralWebserviceException), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__GeneralWebserviceException(struct soap *soap, struct _ns2__GeneralWebserviceException *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns2__GeneralWebserviceException(soap, tag ? tag : "ns2:GeneralWebserviceException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__GeneralWebserviceException ** SOAP_FMAC4 soap_get_PointerTo_ns2__GeneralWebserviceException(struct soap *soap, struct _ns2__GeneralWebserviceException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__GeneralWebserviceException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__AssertionException(struct soap *soap, struct _ns2__AssertionException *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__AssertionException))
		soap_serialize__ns2__AssertionException(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__AssertionException(struct soap *soap, const char *tag, int id, struct _ns2__AssertionException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__AssertionException, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__AssertionException(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__AssertionException ** SOAP_FMAC4 soap_in_PointerTo_ns2__AssertionException(struct soap *soap, const char *tag, struct _ns2__AssertionException **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__AssertionException **)soap_malloc(soap, sizeof(struct _ns2__AssertionException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__AssertionException(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__AssertionException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__AssertionException, sizeof(struct _ns2__AssertionException), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__AssertionException(struct soap *soap, struct _ns2__AssertionException *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns2__AssertionException(soap, tag ? tag : "ns2:AssertionException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__AssertionException ** SOAP_FMAC4 soap_get_PointerTo_ns2__AssertionException(struct soap *soap, struct _ns2__AssertionException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__AssertionException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__T_USCOREUser(struct soap *soap, struct ns3__T_USCOREUser *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__T_USCOREUser))
		soap_serialize_ns3__T_USCOREUser(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__T_USCOREUser(struct soap *soap, const char *tag, int id, struct ns3__T_USCOREUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__T_USCOREUser, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__T_USCOREUser(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__T_USCOREUser ** SOAP_FMAC4 soap_in_PointerTons3__T_USCOREUser(struct soap *soap, const char *tag, struct ns3__T_USCOREUser **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__T_USCOREUser **)soap_malloc(soap, sizeof(struct ns3__T_USCOREUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__T_USCOREUser(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__T_USCOREUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__T_USCOREUser, sizeof(struct ns3__T_USCOREUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__T_USCOREUser(struct soap *soap, struct ns3__T_USCOREUser *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__T_USCOREUser(soap, tag ? tag : "ns3:T_User", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__T_USCOREUser ** SOAP_FMAC4 soap_get_PointerTons3__T_USCOREUser(struct soap *soap, struct ns3__T_USCOREUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__T_USCOREUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__UserIDInfo(struct soap *soap, struct ns3__UserIDInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__UserIDInfo))
		soap_serialize_ns3__UserIDInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__UserIDInfo(struct soap *soap, const char *tag, int id, struct ns3__UserIDInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__UserIDInfo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__UserIDInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__UserIDInfo ** SOAP_FMAC4 soap_in_PointerTons3__UserIDInfo(struct soap *soap, const char *tag, struct ns3__UserIDInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__UserIDInfo **)soap_malloc(soap, sizeof(struct ns3__UserIDInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__UserIDInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__UserIDInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__UserIDInfo, sizeof(struct ns3__UserIDInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__UserIDInfo(struct soap *soap, struct ns3__UserIDInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__UserIDInfo(soap, tag ? tag : "ns3:UserIDInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__UserIDInfo ** SOAP_FMAC4 soap_get_PointerTons3__UserIDInfo(struct soap *soap, struct ns3__UserIDInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__UserIDInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__T_USCOREUserState(struct soap *soap, enum ns3__T_USCOREUserState *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns3__T_USCOREUserState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__T_USCOREUserState(struct soap *soap, const char *tag, int id, enum ns3__T_USCOREUserState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__T_USCOREUserState, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__T_USCOREUserState(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns3__T_USCOREUserState ** SOAP_FMAC4 soap_in_PointerTons3__T_USCOREUserState(struct soap *soap, const char *tag, enum ns3__T_USCOREUserState **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns3__T_USCOREUserState **)soap_malloc(soap, sizeof(enum ns3__T_USCOREUserState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__T_USCOREUserState(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns3__T_USCOREUserState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__T_USCOREUserState, sizeof(enum ns3__T_USCOREUserState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__T_USCOREUserState(struct soap *soap, enum ns3__T_USCOREUserState *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__T_USCOREUserState(soap, tag ? tag : "ns3:T_UserState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns3__T_USCOREUserState ** SOAP_FMAC4 soap_get_PointerTons3__T_USCOREUserState(struct soap *soap, enum ns3__T_USCOREUserState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__T_USCOREUserState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__T_USCORELicenseType(struct soap *soap, enum ns3__T_USCORELicenseType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns3__T_USCORELicenseType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__T_USCORELicenseType(struct soap *soap, const char *tag, int id, enum ns3__T_USCORELicenseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__T_USCORELicenseType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__T_USCORELicenseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns3__T_USCORELicenseType ** SOAP_FMAC4 soap_in_PointerTons3__T_USCORELicenseType(struct soap *soap, const char *tag, enum ns3__T_USCORELicenseType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns3__T_USCORELicenseType **)soap_malloc(soap, sizeof(enum ns3__T_USCORELicenseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__T_USCORELicenseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns3__T_USCORELicenseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__T_USCORELicenseType, sizeof(enum ns3__T_USCORELicenseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__T_USCORELicenseType(struct soap *soap, enum ns3__T_USCORELicenseType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__T_USCORELicenseType(soap, tag ? tag : "ns3:T_LicenseType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns3__T_USCORELicenseType ** SOAP_FMAC4 soap_get_PointerTons3__T_USCORELicenseType(struct soap *soap, enum ns3__T_USCORELicenseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__T_USCORELicenseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__id(struct soap *soap, LONG64 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns3__id);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__id(struct soap *soap, const char *tag, int id, LONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__id, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__id(soap, tag, id, *a, type);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_in_PointerTons3__id(struct soap *soap, const char *tag, LONG64 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (LONG64 **)soap_malloc(soap, sizeof(LONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__id(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (LONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__id, sizeof(LONG64), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__id(struct soap *soap, LONG64 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__id(soap, tag ? tag : "ns3:id", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_get_PointerTons3__id(struct soap *soap, LONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__id(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__T_USCOREForeignKeyList(struct soap *soap, struct ns3__T_USCOREForeignKeyList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__T_USCOREForeignKeyList))
		soap_serialize_ns3__T_USCOREForeignKeyList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__T_USCOREForeignKeyList(struct soap *soap, const char *tag, int id, struct ns3__T_USCOREForeignKeyList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__T_USCOREForeignKeyList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__T_USCOREForeignKeyList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__T_USCOREForeignKeyList ** SOAP_FMAC4 soap_in_PointerTons3__T_USCOREForeignKeyList(struct soap *soap, const char *tag, struct ns3__T_USCOREForeignKeyList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__T_USCOREForeignKeyList **)soap_malloc(soap, sizeof(struct ns3__T_USCOREForeignKeyList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__T_USCOREForeignKeyList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__T_USCOREForeignKeyList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__T_USCOREForeignKeyList, sizeof(struct ns3__T_USCOREForeignKeyList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__T_USCOREForeignKeyList(struct soap *soap, struct ns3__T_USCOREForeignKeyList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__T_USCOREForeignKeyList(soap, tag ? tag : "ns3:T_ForeignKeyList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__T_USCOREForeignKeyList ** SOAP_FMAC4 soap_get_PointerTons3__T_USCOREForeignKeyList(struct soap *soap, struct ns3__T_USCOREForeignKeyList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__T_USCOREForeignKeyList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__T_USCOREIdList(struct soap *soap, struct ns3__T_USCOREIdList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__T_USCOREIdList))
		soap_serialize_ns3__T_USCOREIdList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__T_USCOREIdList(struct soap *soap, const char *tag, int id, struct ns3__T_USCOREIdList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__T_USCOREIdList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__T_USCOREIdList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__T_USCOREIdList ** SOAP_FMAC4 soap_in_PointerTons3__T_USCOREIdList(struct soap *soap, const char *tag, struct ns3__T_USCOREIdList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__T_USCOREIdList **)soap_malloc(soap, sizeof(struct ns3__T_USCOREIdList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__T_USCOREIdList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__T_USCOREIdList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__T_USCOREIdList, sizeof(struct ns3__T_USCOREIdList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__T_USCOREIdList(struct soap *soap, struct ns3__T_USCOREIdList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__T_USCOREIdList(soap, tag ? tag : "ns3:T_IdList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__T_USCOREIdList ** SOAP_FMAC4 soap_get_PointerTons3__T_USCOREIdList(struct soap *soap, struct ns3__T_USCOREIdList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__T_USCOREIdList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__T_USCOREForeignKey(struct soap *soap, struct ns3__T_USCOREForeignKey *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__T_USCOREForeignKey))
		soap_serialize_ns3__T_USCOREForeignKey(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__T_USCOREForeignKey(struct soap *soap, const char *tag, int id, struct ns3__T_USCOREForeignKey *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__T_USCOREForeignKey, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__T_USCOREForeignKey(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__T_USCOREForeignKey ** SOAP_FMAC4 soap_in_PointerTons3__T_USCOREForeignKey(struct soap *soap, const char *tag, struct ns3__T_USCOREForeignKey **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__T_USCOREForeignKey **)soap_malloc(soap, sizeof(struct ns3__T_USCOREForeignKey *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__T_USCOREForeignKey(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__T_USCOREForeignKey **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__T_USCOREForeignKey, sizeof(struct ns3__T_USCOREForeignKey), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__T_USCOREForeignKey(struct soap *soap, struct ns3__T_USCOREForeignKey *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__T_USCOREForeignKey(soap, tag ? tag : "ns3:T_ForeignKey", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__T_USCOREForeignKey ** SOAP_FMAC4 soap_get_PointerTons3__T_USCOREForeignKey(struct soap *soap, struct ns3__T_USCOREForeignKey **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__T_USCOREForeignKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__date(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__date);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__date(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__date);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__date(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__date, 5, 0, -1, "[-+]?\\d{4,}-\\d{2}-\\d{2}(Z|[-+]\\d{2}:\\d{2})?");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__date(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__date(soap, tag ? tag : "xsd:date", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__date(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *p;
	char * *a = (char **)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(char *));
	for (p = a; p && n--; p++)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
